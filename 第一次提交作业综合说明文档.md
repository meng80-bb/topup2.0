# 第一次提交作业综合说明文档

## 文档说明

本文档详细说明了BESIII离线事件滤波器校准流程中**第一次提交作业**（步骤1.1-1.5）的目的、意义、技术实现和物理背景。

**目标读者：** 新用户、需要了解项目背景的开发者、iFlow CLI参考文档

**相关文件：**
- 步骤1.1：`step1_1_first_job_submission.py` - 第一次作业提交
- 步骤1.2：`step1_2_move_files.py` - 移动文件
- 步骤1.3：`step1_3_ist_analysis.py` - IST分析
- 步骤1.4：`step1_4_merge_images.py` - 合并图片
- 操作手册：`A-topup操作.docx`
- 论文：`OfflineEventFilter_rdtm2022.pdf`

---

## 一、第一次提交作业概述

### 什么是第一次提交作业？

第一次提交作业是BESIII离线事件滤波器校准流程的**第一步**，其核心任务是从原始数据中提取注入信号时间戳（IST）和事件时间戳（ETS），为后续的滤波器校准提供时间基准数据。

### 在整个流程中的位置

第一次提交作业对应论文图5所示的离线数据处理流程中的 **"Offline Event Filter Calibration"**（离线事件滤波器校准）的初始阶段，是整个离线事件滤波器系统的**基础和起点**。

### 步骤1的子步骤关系

步骤1包含5个子步骤，形成一个完整的数据处理流程：

```
步骤1.1：第一次作业提交（核心）
    ↓
步骤1.2：检查结果文件并移动
    ↓
步骤1.3：IST分析（验证数据质量）
    ↓
步骤1.4：合并图片（人工审核）
    ↓
步骤1.5：完成并保存进度
```

**说明：**
- **步骤1.1**是核心，负责提交作业并生成时间数据
- **步骤1.2-1.4**是为了服务第一次提交作业，确保数据质量和可追溯性
- 所有步骤共同构成一个完整的数据处理和质量控制流程

---

## 二、第一次提交作业的物理背景

### 研究背景：BEPCII顶部注入（Top-up Injection）

**BEPCII于2019年底实现了顶部注入（top-up injection）：**
- 时间平均积分亮度提高了约30%
- 但频繁的束流注入在数据采集期间造成了明显的注入背景
- 这些背景严重影响了数据质量和物理结果的可靠性

### 核心问题：注入背景污染

**注入背景特征：**

1. **MDC（主漂移室）响应：**
   - 暗电流在注入期间增加约2倍
   - MDC几乎完全被占满，导致径迹重建困难
   - 对束流相关背景最敏感（最靠近束流管）

2. **EMC（电磁量能器）响应：**
   - 总能量沉积可达1000 GeV以上
   - 远高于质心对撞能量（约2.0 GeV）
   - 对束流相关背景也很敏感

**在线触发屏蔽（Online Trigger Veto）的局限性：**
- 每次注入时，加速器系统向触发系统发送注入信号
- 接收到注入信号时间戳（IST）后，激活触发屏蔽窗口
- 屏蔽窗口内的事件被拒绝
- **问题：**由于束流不稳定性，某些严重污染的时期无法被有效屏蔽

### 解决方案：离线事件滤波器（Offline Event Filter）

**离线事件滤波器的作用：**
1. **背景峰值识别：** 基于MDC和EMC的响应识别严重背景污染时期
2. **时间差计算：** 计算 ΔT = ETS - IST（事件相对于注入的时间）
3. **滤波窗口确定：** 使用MDC和EMC的平均占用率和总能量沉积分布确定滤波窗口
4. **事件过滤：** 在事件重建前，离线事件滤波器算法访问数据库，决定保留或跳过每个事件

**应用效果：**
- 有效去除被注入背景污染的数据
- 显著改善数据质量
- 保持最佳数据采集效率
- 有助于避免蒙特卡罗模拟与数据之间的不一致性

---

## 三、第一次提交作业的核心目标

### 1. 提取IST（Injection Signal Time Stamp）

**什么是IST？**

IST是记录每次束流注入精确时间的信号时间戳：
- **时间标记：**每当加速器进行束流注入时，会向触发系统发送一个注入信号
- **周期特征：**反映注入间隔（60ms、20ms或150ms）
- **滤波基准：**为离线事件滤波器提供时间参考

**注入时间间隔（Injection Interval）说明：**

根据配置文件 `GetRawETS.InjectionInterval = 60`，注入间隔为**60毫秒**（对应topup模式）。

常见的注入间隔值：
- **60ms**：标准topup注入模式（默认）
- **20ms**：topup周期改变时的注入间隔
- **150ms**：非topup注入模式（长周期）

### 2. 提取ETS（Event Time Stamp）

**什么是ETS？**

ETS是记录每个事件发生精确时间的时间戳：
- **事件标记：**每个探测器读出事件都有一个ETS
- **时间精度：**通常为纳秒级别
- **时间对齐：**与IST对齐，计算事件与注入的时间差

### 3. 计算ΔT = ETS - IST

**ΔT的物理意义：**

ΔT表示事件相对于最近一次注入的时间差：
- **ΔT > 0**：事件发生在注入之后
- **ΔT ≈ 0**：事件发生在注入时刻（严重污染）
- **ΔT < 0**：事件发生在注入之前（不受影响）

**滤波窗口的确定：**

通过分析MDC和EMC响应随ΔT的分布，确定滤波窗口：
- 在ΔT = 0附近，MDC占用率和EMC能量沉积显著增加
- 滤波窗口应该覆盖这些污染严重的区域
- 通常为注入前后几毫秒的范围

### 4. 为后续步骤提供数据基础

**后续步骤依赖：**
- **步骤2（第二次作业）：** 使用InjSigTime文件生成hist文件，分析MDC/EMC响应
- **步骤3-6（滤波器校准）：** 基于ΔT分析确定滤波窗口参数
- **步骤7（提交数据库）：** 将滤波器参数保存到离线校准数据库

---

## 四、genJob.sh脚本详解

### 脚本功能

`genJob.sh` 脚本是第一次提交作业的核心，负责：
1. 遍历数据目录中的所有run文件
2. 为每个run创建作业配置文件
3. 使用BOSS框架提交作业到计算集群

### 脚本内容详解

```bash
#!/bin/bash
#-----------------------------------------------------
# 生成作业脚本
#-----------------------------------------------------

if [ $# -lt 1 ]; then
  echo "generate job. Usage: $0 date(eg. 110311)"
  exit
fi

date=$1
pwdir=`pwd`
tempFile=${pwdir}/temp.txt
dataPath=/bes3fs/offline/data/cal/round18/${date}
LastRun=-1
nfile=0

# 检查日期目录是否已存在
if [ -e $1 ]; then
    echo "ERROR: ${1} exists"
    exit
fi

# 创建日期目录
mkdir $1
cd $1

# 遍历数据目录中的所有run文件
for file in `/bin/ls ${dataPath}/*run*`;
do
  fileName=`echo $file | sed 's/.*\///g'`
  CurRun=${fileName:6:5}  # 提取run编号（从第6位开始，长度5）

  if [[ ${CurRun} != ${LastRun} ]]; then
    echo $CurRun
    LastRun=$CurRun

    # 为每个run创建作业配置文件
    calJob=rec${CurRun}_1.txt
    cp $tempFile $calJob
    sed -i  's|RUNNO|'"${CurRun}"'|g' $calJob

    # 添加输入文件列表
    for calFile in `/bin/ls ${dataPath}/*${CurRun}*raw`;
    do
      sed -i 's|INPUTFILE|'\"${calFile}\"\\n',INPUTFILE|' $calJob
    done
    sed -i 's|,INPUTFILE||' $calJob
  fi
done

# 提交所有作业
for file in rec*.txt
do
  echo $file
  chmod +x $file
  boss.condor -g offlinerun  $file
  nfile=`expr $nfile + 1`
done

echo "Total = $nfile files"
echo "DONE"
```

### 关键步骤说明

1. **数据路径解析：**
   - 从文件名中提取run编号（如run_0085383_XXX → 85383）
   - 每个run可能有多个raw文件（不同物理过程）

2. **作业配置文件生成：**
   - 使用temp.txt模板
   - 替换RUNNO占位符为实际run编号
   - 添加所有相关的raw文件到输入文件列表

3. **作业提交：**
   - 使用BOSS框架的condor系统
   - 每个run作为一个独立的作业提交
   - 作业在计算集群上并行执行

---

## 五、temp.txt作业模板详解

### 模板功能

`temp.txt` 是BOSS框架的作业配置模板，定义了作业执行的算法、参数和输入输出。

### 模板内容详解

```python
#include "$RAWDATACNVROOT/share/ReadRawDatajobOptions_dataValid.txt"
#include "$OFFLINEEVENTLOOPMGRROOT/share/OfflineEventLoopMgr_Option.txt"
#include "$CALIBSVCROOT/share/job-CalibData.txt"
#include "$CALIBSVCROOT/share/calibConfig_rec_data.txt"
#include "$INJSIGINTERVALSVCROOT/share/jobOptions_InjSigIntervalSvc.txt"
#include "$GETTINTERVALALGROOT/share/jobOptions_GetTIntervalAlg.txt"

ApplicationMgr.DLLs += {"GetRawETS"};
ApplicationMgr.TopAlg += { "GetRawETS" };

GetTIntervalAlg.output = "Interval_runRUNNO.txt";
GetTIntervalAlg.dump = false;

GetRawETS.dump = false;
GetRawETS.NumFill = 1;  //the number of fillings before and after each injection
GetRawETS.FirstEvtInTopUpFlag = 3;
GetRawETS.ETS_FILE = "InjSigTime_00RUNNO_720.root";
GetRawETS.ReadFromDB = false;
GetRawETS.InjectionInterval = 60;  // 注入间隔（毫秒）

RawDataInputSvc.InputFiles={
INPUTFILE
};

MessageSvc.OutputLevel = 5;
ApplicationMgr.EvtMax = -1;
```

### 关键组件说明

#### 1. 包含的头文件

```python
#include "$RAWDATACNVROOT/share/ReadRawDatajobOptions_dataValid.txt"
```
- 原始数据转换服务配置
- 定义如何读取raw格式的数据文件

```python
#include "$OFFLINEEVENTLOOPMGRROOT/share/OfflineEventLoopMgr_Option.txt"
```
- 离线事件循环管理器配置
- 定义事件处理流程

```python
#include "$INJSIGINTERVALSVCROOT/share/jobOptions_InjSigIntervalSvc.txt"
```
- 注入信号间隔服务配置
- 提供IST读取功能

```python
#include "$GETTINTERVALALGROOT/share/jobOptions_GetTIntervalAlg.txt"
```
- 获取时间间隔算法配置
- 定义如何计算ΔT

#### 2. GetRawETS算法

```python
ApplicationMgr.DLLs += {"GetRawETS"};
ApplicationMgr.TopAlg += { "GetRawETS" };

GetRawETS.ETS_FILE = "InjSigTime_00RUNNO_720.root";
GetRawETS.ReadFromDB = false;
GetRawETS.InjectionInterval = 60;
```

**功能：**
- 从原始数据中提取每个事件的ETS
- 记录每次束流注入的IST
- 将时间信息保存到ROOT文件

**参数说明：**
- `ETS_FILE`：输出文件名，包含IST和ETS数据
- `ReadFromDB`：是否从数据库读取IST（false表示从数据文件提取）
- `InjectionInterval`：注入间隔（60ms）

#### 3. GetTIntervalAlg算法

```python
GetTIntervalAlg.output = "Interval_runRUNNO.txt";
GetTIntervalAlg.dump = false;
```

**功能：**
- 计算 ΔT = ETS - IST
- 生成Interval文件，记录每个事件与注入的时间差
- 保存注入时间间隔信息

**输出格式：**
```
                    85383
  interval_before_sorting                 15000000
         interval_From_DB                 15000000
   interval_after_sorting                 15000000
```

---

## 六、输出文件详解

### 1. InjSigTime_00{run}_720.root

**格式：** ROOT文件

**内容：**
- IST（注入信号时间戳）数组
- ETS（事件时间戳）数组
- 每个事件的元数据

**用途：**
- 为离线事件滤波器校准提供时间基准数据
- 后续步骤用于计算MDC/EMC响应与ΔT的关系

**物理意义：**
- IST记录每次注入的精确时间
- ETS记录每个事件的精确时间
- 通过两者之差确定事件与注入的相对时间

### 2. Interval_run{run}.txt

**格式：** 文本文件

**内容：**
```
                    {run_number}
  interval_before_sorting                 {interval_ms}
         interval_From_DB                 {interval_ms}
   interval_after_sorting                 {interval_ms}
```

**关键字段说明：**

| 字段 | 含义 | 单位 | 来源 |
|------|------|------|------|
| interval_From_DB | 从数据库读取的注入时间间隔 | 毫秒 | 数据库 |
| interval_before_sorting | 排序前的注入时间间隔 | 毫秒 | 原始数据计算 |
| interval_after_sorting | 排序后的注入时间间隔 | 毫秒 | 统计筛选 |

**排序的含义：**

"排序"在这里指的是对注入事件序列的处理和筛选：
- **排序前：**直接从原始数据中计算的注入时间间隔，可能包含噪声或异常值
- **排序后：**经过统计分析和筛选后确定的典型注入时间间隔，代表该run的主要注入模式

**常见值及含义：**

| interval_after_sorting值 | 模式分类 | 物理意义 | 处理方式 |
|------------------------|---------|---------|---------|
| 60 | 标准topup模式 | 正常的顶部注入，60毫秒间隔 | 使用标准滤波器参数 |
| 20 | 周期改变模式 | 注入周期缩短，更频繁注入 | 调整滤波器参数适应短周期 |
| 150 | 非topup模式 | 传统注入模式，长周期 | 使用特殊滤波器配置 |
| 其他值/混合 | 异常模式 | 数据质量问题或特殊配置 | 需要人工检查和处理 |

### 3. Interval_run{run}.png

**格式：** PNG图片文件

**内容：**
- IST分布直方图
- ΔT分布图
- 时间序列图

**用途：**
- 人工审核数据质量
- 识别异常注入事件
- 验证注入模式是否稳定

---

## 七、步骤1的子步骤详解

### 步骤1.1：第一次作业提交

**功能：**
- 确定日期参数（或对比获取）
- 删除已存在的日期目录（支持自动重新提交）
- 执行genJob.sh脚本
- 检查结果文件是否完整

**关键特性：**
1. **日期自动获取：**
   - 如果传入date参数，直接使用
   - 如果未传入，对比已处理和可用数据目录，找出最小未处理日期

2. **自动重新提交：**
   - 如果日期目录已存在，自动删除
   - 确保作业提交时的数据是干净的

3. **定时检查：**
   - 默认等待25分钟，每30秒检查一次
   - 支持通过参数自定义等待时间

4. **文件检查：**
   - 检查每个run是否生成了必需的文件：
     - `InjSigTime_00{run}_720.root`
     - `Interval_run{run}.txt`
     - `Interval_run{run}.png`
   - 记录未完成的run号

5. **异常检测：**
   - 检查是否出现了`Interval_run0.png`文件（数据异常）
   - 如果发现，立即停止并提示人工干预

**示例运行：**

```bash
# 方法1：指定日期
python run.py --step 1.1 --date 250519

# 方法2：自动获取日期
python run.py --step 1.1

# 方法3：自定义等待时间
python run.py --step 1.1 --date 250519 --max-wait 30
```

### 步骤1.2：移动文件

**功能：**
- 将`InjSigTime*.root`文件移动到`../calibConst`目录
- 将`Interval*.png`文件移动到`../Interval_plot`目录

**目的：**
- 按文件类型分类存储，便于后续处理
- calibConst目录用于存储校准数据
- Interval_plot目录用于存储检查图片

**验证：**
- 移动后验证文件是否成功移动
- 显示剩余文件列表

### 步骤1.3：IST分析

**功能：**
- 检查每个run号的Interval文件中的interval值
- 验证所有run号的IST值是否符合预期
- 将结果追加到interval.txt文件

**检查参数（check参数）：**

| check值 | 行为 | 适用场景 |
|---------|------|---------|
| True（默认） | 严格检查，IST值不等于预期时返回错误 | 标准topup模式 |
| False | 不检查，直接记录结果 | 临时调试或特殊模式 |

**重要说明：**

**当前实现（临时）：**
- 步骤1.3中的IST值检查（验证是否等于15000000）是当前为了处理非topup数据而设置的特定检测条件
- 这是一个**暂时的权宜之计**

**未来改进：**
- 以后需要支持处理IST不等于15000000的模式（如60ms、20ms）
- 需要根据不同的注入模式进行不同的处理策略
- 可能需要添加模式识别和自动切换功能

**Interval文件分析：**

步骤1.3会分析每个run的Interval文件，检查三个关键字段：

1. **interval_From_DB**：从数据库读取的注入时间间隔
2. **interval_before_sorting**：排序前的注入时间间隔
3. **interval_after_sorting**：排序后的注入时间间隔

**可能的分析结果：**

#### 结果1：三个值一致（最常见）

```
interval_From_DB: 60
interval_before_sorting: 60
interval_after_sorting: 60
```

**含义：**
- 数据质量良好，注入模式稳定
- 数据库记录与实际测量结果一致
- 没有异常注入事件
- 可以直接使用60ms作为注入间隔参数

#### 结果2：三个值中有差异

```
interval_From_DB: 60
interval_before_sorting: 60, 150, 20, 60, 60...
interval_after_sorting: 60
```

**含义：**
- 原始数据中存在多种注入间隔（混合模式）
- 排序后选择了最主要的模式（60ms）
- 可能发生了模式切换或偶尔的非topup注入
- 排序后的值（60ms）代表该run的主要特征

#### 结果3：interval_after_sorting 为150ms

```
interval_From_DB: 150
interval_before_sorting: 150
interval_after_sorting: 150
```

**含义：**
- 该run处于非topup模式
- 注入间隔较长（150ms）
- 需要特殊的滤波器配置
- 步骤1.3中的15000000检测就是针对这种情况

#### 结果4：interval_after_sorting 为20ms

```
interval_From_DB: 20
interval_before_sorting: 20
interval_after_sorting: 20
```

**含义：**
- topup周期改变（缩短注入间隔）
- 注入间隔为20ms
- 需要调整滤波器参数
- 可能是实验需要更频繁注入的特殊时期

#### 结果5：interval_before_sorting 和 interval_after_sorting 差异很大

```
interval_From_DB: 60
interval_before_sorting: 多种混合值（60, 150, 20, 异常值）
interval_after_sorting: 60（但可能不准确）
```

**含义：**
- 数据质量较差，存在大量异常
- 注入模式不稳定
- 需要人工检查和干预
- 可能需要重新运行该run的作业

### 步骤1.4：合并图片

**功能：**
- 进入Interval_plot目录
- 使用SL6容器执行ImageMagick的convert命令
- 将所有PNG图片合并为一个PDF文件
- 下载PDF文件到本地

**技术细节：**

1. **容器环境：**
   - 使用`/cvmfs/container.ihep.ac.cn/bin/hep_container shell SL6`进入SL6容器
   - 容器中预装了ImageMagick工具

2. **图片合并：**
   - 使用`convert *.png mergedd_IST.pdf`命令
   - 按文件名顺序合并所有PNG图片
   - 输出文件名为`mergedd_IST.pdf`

3. **文件下载：**
   - 使用SFTP协议下载PDF文件
   - 保存到本地`downloads/`目录
   - 文件名格式：`mergedd_IST_{date}.pdf`

**用途：**
- 方便人工审核所有run的IST图片
- 可以快速浏览数据质量
- 便于存档和共享

### 步骤1.5：完成并保存进度

**功能：**
- 保存当前步骤的执行进度到`.step_progress`文件
- 记录当前处理的日期
- 支持断点续传

**进度文件格式：**

```json
{
  "step": "1.5",
  "date": "250519",
  "timestamp": "2026-02-13 15:30:00"
}
```

**断点续传：**

```bash
# 从断点继续执行
python run.py --continue
```

---

## 八、第一次提交作业在离线事件滤波器中的作用

### 数据流程图

```
Raw Data
    ↓
[步骤1.1：第一次作业提交]
    ├─ 读取原始数据文件（*.raw）
    ├─ 运行 GetRawETS 算法
    │  ├─ 提取注入信号时间戳（IST）
    │  ├─ 提取事件时间戳（ETS）
    │  └─ 保存到 InjSigTime_00{run}_720.root
    └─ 运行 GetTIntervalAlg 算法
       ├─ 计算 ΔT = ETS - IST
       └─ 保存到 Interval_run{run}.txt
    ↓
InjSigTime_00{run}_720.root（包含IST和ETS）
Interval_run{run}.txt（包含ΔT和interval信息）
    ↓
[步骤1.2：移动文件]
    ├─ 移动root文件到calibConst目录
    └─ 移动png文件到Interval_plot目录
    ↓
[步骤1.3：IST分析]
    ├─ 检查interval值
    ├─ 验证注入模式
    └─ 追加到interval.txt文件
    ↓
[步骤1.4：合并图片]
    ├─ 合并所有PNG图片为PDF
    └─ 下载到本地
    ↓
[步骤1.5：保存进度]
    └─ 保存执行进度
    ↓
[步骤2：第二次作业]
    ├─ 读取InjSigTime文件
    ├─ 生成hist文件
    └─ 分析MDC/EMC响应
    ↓
[步骤3-6：滤波器校准]
    ├─ 分析MDC/EMC响应 vs ΔT
    ├─ 识别背景峰值
    ├─ 确定滤波窗口参数
    └─ 保存到校准数据库
    ↓
[步骤7：提交数据库]
    └─ 将滤波器参数保存到数据库
    ↓
在事件重建时应用滤波器
```

### 物理意义

通过准确提取和分析事件时间与注入时间的关系，第一次提交作业为：
- 识别注入背景污染事件
- 确定最优滤波窗口
- 提高数据质量
- 保证物理结果的可靠性

提供了关键的输入数据。

### 与论文的对应

第一次提交作业对应论文中图5的 **"Offline Event Filter Calibration"** 框的起始部分，是实现离线事件滤波器的必要前提。

---

## 九、示例：run85383的完整流程

### 1. 数据文件

```bash
/topup/250519/run_0085383_BBhabha_file001_SFO-1.raw
/topup/250519/run_0085383_GBBhabha_file001_SFO-1.raw
/topup/250519/run_0085383_GDimuon_file001_SFO-1.raw
/topup/250519/run_0085383_GDiphoton_file001_SFO-1.raw
/topup/250519/run_0085383_GEBhabha_file001_SFO-1.raw
```

### 2. 作业配置文件（rec85383_1.txt）

```python
#include "$RAWDATACNVROOT/share/ReadRawDatajobOptions_dataValid.txt"
#include "$OFFLINEEVENTLOOPMGRROOT/share/OfflineEventLoopMgr_Option.txt"
#include "$CALIBSVCROOT/share/job-CalibData.txt"
#include "$CALIBSVCROOT/share/calibConfig_rec_data.txt"
#include "$INJSIGINTERVALSVCROOT/share/jobOptions_InjSigIntervalSvc.txt"
#include "$GETTINTERVALALGROOT/share/jobOptions_GetTIntervalAlg.txt"

ApplicationMgr.DLLs += {"GetRawETS"};
ApplicationMgr.TopAlg += { "GetRawETS" };

GetTIntervalAlg.output = "Interval_run85383.txt";
GetTIntervalAlg.dump = false;

GetRawETS.dump = false;
GetRawETS.NumFill = 1;
GetRawETS.FirstEvtInTopUpFlag = 3;
GetRawETS.ETS_FILE = "InjSigTime_0085383_720.root";
GetRawETS.ReadFromDB = false;
GetRawETS.InjectionInterval = 60;

RawDataInputSvc.InputFiles={
"/bes3fs/offline/data/cal/round18/250519/run_0085383_BBhabha_file001_SFO-1.raw"
,"/bes3fs/offline/data/cal/round18/250519/run_0085383_GBBhabha_file001_SFO-1.raw"
,"/bes3fs/offline/data/cal/round18/250519/run_0085383_GDimuon_file001_SFO-1.raw"
,"/bes3fs/offline/data/cal/round18/250519/run_0085383_GDiphoton_file001_SFO-1.raw"
,"/bes3fs/offline/data/cal/round18/250519/run_0085383_GEBhabha_file001_SFO-1.raw"
};

MessageSvc.OutputLevel = 5;
ApplicationMgr.EvtMax = -1;
```

### 3. 输出文件

**Interval_run85383.txt：**
```
                    85383
  interval_before_sorting                 15000000
         interval_From_DB                 15000000
   interval_after_sorting                 15000000
```

**说明：**
- run85383的注入间隔为15000000微秒（150ms）
- 这是非topup模式
- 三个值一致，数据质量良好

**错误文件（rec85383_1.txt.bosserr）：**
```
Error in <TGraphPainter::PaintGraph>: illegal number of points (0)
Info in <TCanvas::Print>: png file Interval_run85383.png has been created
```

**说明：**
- 警告信息，不影响主要功能
- PNG图片成功生成

### 4. 日志文件摘要

**关键信息：**
```
Job 51149089.0 submitted at 2026-02-13 15:22:10
BOSS version: 7.2.0
GetRawETS::execute() m_interval = 60
[RawFile] Prepare for reading: run_0085383_BBhabha_file001_SFO-1.raw
[RawFile] Reach end of data file: run_0085383_BBhabha_file001_SFO-1.raw
[RawFile] Prepare for reading: run_0085383_GBBhabha_file001_SFO-1.raw
[RawFile] Reach end of data file: run_0085383_GBBhabha_file001_SFO-1.raw
...
[RawFile] Congratulations. Reach end of data file list !
ApplicationMgr Stopped successfully
```

**说明：**
- 作业成功提交并执行
- 所有raw文件都被正确读取
- 没有严重错误

---

## 十、常见问题和解决方法

### 问题1：作业提交失败

**症状：**
```
ERROR: 250519 exists
```

**原因：**
- 日期目录已存在

**解决方法：**
- 步骤1.1会自动删除已存在的日期目录
- 如果仍然失败，手动删除：`rm -rf /path/to/250519`

### 问题2：文件检查超时

**症状：**
```
在 25 分钟内未完成所有文件的生成
```

**原因：**
- 计算集群负载高
- run数量多
- 网络问题

**解决方法：**
- 增加等待时间：`python run.py --step 1.1 --date 250519 --max-wait 30`
- 检查作业状态：`hep_q -u topup`
- 重新提交失败的作业

### 问题3：IST值不等于预期

**症状：**
```
IST的值不全为15000000，不为非topup模式
```

**原因：**
- 数据处于不同的注入模式
- 混合模式的run

**解决方法：**
- 检查每个run的Interval文件
- 根据实际情况调整处理策略
- 人工审核后决定是否继续

### 问题4：Interval_run0.png异常

**症状：**
```
出现了Interval_run0.png的文件，该日期数据不正常
```

**原因：**
- 数据异常
- run编号解析错误
- 严重的数据质量问题

**解决方法：**
- 停止处理该日期
- 检查原始数据文件
- 联系数据管理员

### 问题5：图片合并失败

**症状：**
```
执行图片合并失败
```

**原因：**
- 容器环境问题
- ImageMagick未安装
- 磁盘空间不足

**解决方法：**
- 检查容器是否正常：`/cvmfs/container.ihep.ac.cn/bin/hep_container shell SL6`
- 检查ImageMagick是否可用：`convert --version`
- 检查磁盘空间：`df -h`

---

## 十一、总结

### 第一次提交作业的本质

第一次提交作业是 **BESIII离线事件滤波器校准流程的第一步**，其核心任务是：

1. **从原始数据中提取时间信息**：提取IST（注入信号时间戳）和ETS（事件时间戳）
2. **计算事件与注入的时间关系**：计算ΔT = ETS - IST
3. **为后续滤波器校准提供数据基础**：这些时间数据是后续分析MDC/EMC响应、确定滤波窗口的基础

### 关键技术点

1. **genJob.sh脚本**：自动化作业生成和提交
2. **BOSS框架**：高能物理数据处理框架
3. **GetRawETS算法**：提取IST和ETS
4. **GetTIntervalAlg算法**：计算ΔT
5. **定时检查机制**：确保作业完成
6. **异常检测**：识别数据质量问题

### 物理意义

通过准确提取和分析事件时间与注入时间的关系，第一次提交作业为：
- 识别注入背景污染事件
- 确定最优滤波窗口
- 提高数据质量
- 保证物理结果的可靠性

提供了关键的输入数据。

### 未来改进方向

1. **支持多种注入模式：**
   - 当前主要支持非topup模式（150ms）
   - 需要扩展支持标准topup模式（60ms）和周期改变模式（20ms）
   - 实现自动模式识别和切换

2. **增强异常检测：**
   - 添加更多数据质量检查
   - 实现更智能的异常识别算法
   - 提供更详细的错误诊断信息

3. **优化性能：**
   - 并行处理多个run
   - 优化文件传输
   - 减少等待时间

4. **改进用户体验：**
   - 提供更详细的进度显示
   - 支持断点续传
   - 提供可视化界面

---

## 附录A：相关文件路径

### 远程服务器路径

```
/besfs5/groups/cal/topup/round18/DataValid/InjSigTimeCal/    # 工作目录
/bes3fs/offline/data/cal/round18/                          # 数据目录
/besfs5/groups/cal/topup/round18/DataValid/calibConst/     # 校准数据目录
/besfs5/groups/cal/topup/round18/DataValid/Interval_plot/  # 检查图片目录
```

### 本地路径

```
C:\Users\孟皇薪\Desktop\topup\downloads\                    # 下载目录
C:\Users\孟皇薪\Desktop\topup\logs\                         # 日志目录
C:\Users\孟皇薪\Desktop\topup\.step_progress                # 进度文件
```

---

## 附录B：命令参考

### 执行步骤

```bash
# 执行单个步骤
python run.py --step 1.1 --date 250519

# 执行所有步骤
python run.py --all --date 250519

# 从断点继续
python run.py --continue

# 批量处理（total模式）
python run.py --total
```

### 查看作业状态

```bash
# 查看topup用户的作业
hep_q -u topup -g physics

# 查看所有用户的作业
hep_q -u

# 查看具体作业详情
hep_q -j <job_id>
```

### 手动操作

```bash
# 进入工作目录
cd /besfs5/groups/cal/topup/round18/DataValid/InjSigTimeCal

# 提交作业
./genJob.sh 250519

# 查看文件数量
ls *root | wc -l
ls *png | wc -l
ls *txt | wc -l

# 移动文件
mv InjSigTime*.root ../calibConst
mv Interval*.png ../Interval_plot

# 检查IST值
grep -r interval_From_DB
grep -r interval_before_sorting
grep -r interval_after_sorting

# 进入SL6容器
/cvmfs/container.ihep.ac.cn/bin/hep_container shell SL6

# 合并图片
convert *.png mergedd.pdf

# 退出容器
exit
```

---

## 附录C：术语表

| 术语 | 英文 | 含义 |
|------|------|------|
| IST | Injection Signal Time Stamp | 注入信号时间戳 |
| ETS | Event Time Stamp | 事件时间戳 |
| ΔT | Delta Time | 事件与注入的时间差 |
| MDC | Main Drift Chamber | 主漂移室 |
| EMC | Electromagnetic Calorimeter | 电磁量能器 |
| BOSS | BESIII Offline Software System | BESIII离线软件系统 |
| topup | top-up injection | 顶部注入 |
| ROOT | ROOT Data Analysis Framework | ROOT数据分析框架 |
| condor | HTCondor Job Scheduler | HTCondor作业调度系统 |

---

**文档创建时间：** 2026年2月7日  
**最后更新时间：** 2026年2月13日  
**基于论文：** "Suppression of top-up injection backgrounds with offline event filter in the BESIII experiment" (Radiation Detection Technology and Methods, 2022)  
**作者：** iFlow CLI