# 第五次提交作业综合说明文档

## 文档说明

本文档详细说明了BESIII离线事件滤波器校准流程中**第五次提交作业**（步骤5.1-5.4）的目的、意义、技术实现和物理背景。

**目标读者：** 新用户、需要了解项目背景的开发者、iFlow CLI参考文档

**相关文件：**
- 步骤5.1：`step5_1_fifth_job_submission.py` - 第五次作业提交并检查cut和all文件（合并版）
- 步骤5.2：`step5_2_run_add_shield_script.py` - 运行add_shield.sh脚本
- 步骤5.3：`step5_3_organize_ets_cut_file.py` - 整理ets_cut.txt文件
- 步骤5.4：`step5_4_merge_images.py` - 合并ETS_cut图片
- 远程脚本：`genJob.sh` - 作业提交脚本
- 核心程序：`ETS_cut.cpp` - ETS切割分析程序
- 操作手册：`A-topup操作.docx`
- 论文：`OfflineEventFilter_rdtm2022.pdf`

---

## 一、第五次提交作业概述

### 什么是第五次提交作业？

第五次提交作业是BESIII离线事件滤波器校准流程中的**ETS切割确定阶段**，其核心任务是分析第二次提交作业生成的hist文件，在MDC响应分布中识别背景峰值，使用两阶段算法（粗粒度+细粒度）精确计算滤波窗口的起始和结束时间，并生成ets_cut.txt文件，为最终的滤波器应用提供精确的参数。

### 在整个流程中的位置

第五次提交作业对应论文图5所示的离线数据处理流程中的 **"精细滤波窗口确定"** 环节，是从"粗略滤波窗口"到"精确ETS切割参数"的关键步骤。

```
步骤4.2：生成mergedd_CheckShieldCalib.pdf
    ↓
[步骤5.1：第五次作业提交]
    ├─ 删除旧文件（plot*和run*）
    ├─ 提交作业（可选submit_job参数）
    ├─ 检查cut和all文件
    └─ 定时检查所有run完成
    ↓
[步骤5.2：运行add_shield.sh脚本]
    ├─ 合并所有shield_run*.txt文件
    └─ 生成ets_cut.txt文件
    ↓
[步骤5.3：整理ets_cut.txt文件]
    ├─ 删除单数字行
    ├─ 按run号排序
    └─ 删除重复行
    ↓
[步骤5.4：合并图片]
    ├─ 进入ETS_cut目录
    ├─ 在SL6容器中合并PNG图片为PDF
    └─ 下载PDF到本地
    ↓
ets_cut.txt文件（精确ETS切割参数）
    ↓
[步骤6：第六次作业]
    ├─ 应用ETS切割参数
    ├─ 生成最终检查图片
    └─ 验证滤波效果
    ↓
[步骤7：提交数据库]
    └─ 将滤波器参数保存到数据库
    ↓
在事件重建时应用滤波器
```

### 步骤5的子步骤关系

步骤5包含4个子步骤，形成一个完整的ETS切割确定流程：

```
步骤5.1：第五次作业提交（核心）
    ├─ 删除旧文件（plot*和run*）
    ├─ 提交作业（可选submit_job参数）
    ├─ 检查cut和all文件
    └─ 定时检查所有run完成
    ↓
步骤5.2：运行add_shield.sh脚本
    ├─ 合并所有shield_run*.txt文件
    └─ 生成ets_cut.txt文件
    ↓
步骤5.3：整理ets_cut.txt文件
    ├─ 删除单数字行
    ├─ 按run号排序
    └─ 删除重复行
    ↓
步骤5.4：合并图片
    ├─ 进入ETS_cut目录
    ├─ 在SL6容器中合并PNG图片为PDF
    └─ 下载PDF到本地
```

**说明：**
- **步骤5.1**是核心，负责提交作业并生成cut和all文件
- **步骤5.2**负责合并所有run的结果，生成ets_cut.txt文件
- **步骤5.3**负责整理ets_cut.txt文件，确保格式正确
- **步骤5.4**负责合并所有run的检查图片，便于批量查看
- 所有步骤共同完成从histogram数据到精确ETS切割参数的转换

### 与前四次提交作业的区别

| 对比项 | 第一次提交作业 | 第二次提交作业 | 第三次提交作业 | 第四次提交作业 | 第五次提交作业 |
|-------|--------------|--------------|--------------|--------------|--------------|
| **输入数据** | 原始数据（*.raw文件） | 第一次提交的ROOT文件 | 第二次提交的hist文件 | 第三次提交的window.dat | 第二次提交的hist文件 |
| **输出文件** | InjSigTime文件、Interval文件 | hist*.root、check*.png | shield_run*.txt、window.dat | run{runNo}_*.png、mergedd_CheckShieldCalib.pdf | run{runNo}_cut.png、run{runNo}_total.png、shield_run*.txt、ets_cut.txt、mergedd_ETSCut.pdf |
| **核心算法** | GetRawETS、GetTIntervalAlg | ResetEtsAlg、OfflineEvtFilterCalibAlg | Search_peak.cpp（寻峰算法） | checkCalibConst.cpp（滤波器验证） | ETS_cut.cpp（精细寻峰算法） |
| **物理意义** | 提取时间戳（IST和ETS）、计算ΔT | 分析探测器响应与ΔT的关系 | 识别背景峰值，确定滤波窗口 | 应用滤波窗口，验证滤波效果 | 精确识别背景峰值，确定ETS切割参数 |
| **后续用途** | 计算ΔT = ETS - IST | 识别背景峰值 | 应用滤波窗口到事件 | 滤波器优化、ETS_cut确定 | 最终滤波器应用 |
| **关键输出** | interval.txt（注入间隔） | histogram文件 | window.dat（滤波窗口参数） | 检查图片、统计信息 | ets_cut.txt（ETS切割参数） |
| **算法特点** | 单阶段处理 | 单阶段处理 | 单阶段处理 | 应用验证 | 两阶段处理（粗粒度+细粒度） |

---

## 二、第五次提交作业的物理背景

### 研究背景：BEPCII顶部注入（Top-up Injection）

**BEPCII于2019年底实现了顶部注入（top-up injection）：**
- 时间平均积分亮度提高了约30%
- 但频繁的束流注入在数据采集期间造成了明显的注入背景
- 这些背景严重影响了数据质量和物理结果的可靠性

### 核心问题：注入背景污染

**注入背景特征：**

1. **MDC（主漂移室）响应：**
   - 暗电流在注入期间增加约2倍
   - MDC几乎完全被占满，导致径迹重建困难
   - 对束流相关背景最敏感（最靠近束流管）
   - 论文图4a显示：在ΔT很小（0-10ms）时，MDC占用率可达60%以上（4000+ hits）

2. **EMC（电磁量能器）响应：**
   - 总能量沉积可达1000 GeV以上
   - 远高于质心对撞能量（约2.0 GeV）
   - 对束流相关背景也很敏感
   - 论文图4b显示：在ΔT很小时，EMC能量沉积可达200 GeV以上

### 精确ETS切割的必要性

**为什么需要两阶段算法？**

步骤3（第三次提交作业）使用的Search_peak.cpp算法虽然能够识别背景峰值，但其精度有限：

1. **bin宽度限制**：hist文件的bin宽度为0.02ms（50Hz周期的一半）
2. **粗粒度阈值**：使用简单的阈值比较，容易遗漏小峰值
3. **边界不准确**：峰值的起始和结束位置可能存在1-2个bin的误差

**两阶段算法的优势：**

ETS_cut.cpp采用两阶段算法：
1. **粗粒度阶段**：使用散点图识别潜在峰值区域
2. **细粒度阶段**：在每个区域使用加权直方图精确计算峰值边界

这种方法能够：
- 更准确地识别小峰值
- 精确计算峰值的起始和结束位置
- 减少误判和漏判
- 提高滤波器的性能

### 与步骤3的区别

| 特性 | 步骤3（Search_peak.cpp） | 步骤5（ETS_cut.cpp） |
|------|----------------------|---------------------|
| **bin宽度** | 0.02ms | 0.005ms（4倍精度） |
| **阈值计算** | 动态计算（2.7倍超出平均值） | 动态计算（5%噪声标准） |
| **峰值识别** | 单阶段 | 两阶段（散点图+加权直方图） |
| **边界扩展** | 固定扩展逻辑 | 智能扩展（合并相邻窗口） |
| **噪声过滤** | 过滤窄峰（<3 bins） | 更严格的噪声过滤 |
| **输出格式** | shield_run*.txt | shield_run*.txt + ets_cut.txt |
| **精度** | 中等 | 高 |

---

## 三、第五次提交作业的核心目标

### 1. 精确识别背景峰值

**目标：** 使用两阶段算法精确识别所有背景峰值

**阶段1：粗粒度寻峰（散点图分析）**

```cpp
// 散点图：MDC hits > 1000的事件
if (nhit_TQ_total_mdc > 1000) {
    ppeak1.push_back(y);  // y = ets1/2000000
}

// 检测密集区域
for (unsigned int i = 0; i < ppeak1.size(); i++) {
    if (ppeak1[i] - tmp < 1) {  // bin宽度为1秒
        countt++;
        if (countt >= 10) {  // 连续10个bin
            ppeak2.push_back(tmp - 0.1);
            ppeak2.push_back(tmp + 1);
        }
    }
}
```

**阶段2：细粒度寻峰（加权直方图分析）**

```cpp
// 在每个窗口内创建高精度直方图
for (unsigned int i = 0; i < window2.size() - 1; i = i + 2) {
    double xmin2 = window2[i];
    double xmax2 = window2[i + 1];
    int xbin2 = (xmax2 - xmin2) / 0.005;  // bin宽度为0.005ms

    h[i] = new TH1F(hist, "", xbin2, xmin2, xmax2);
    for (int j = 0; j < entries; j++) {
        tr->GetEntry(j);
        double y = ets1 / 2000000;
        if (trigChannel_9 == 0) {
            h[i]->Fill(y, nhit_TQ_total_mdc);  // 使用MDC hits作为权重
        }
    }

    // 在高精度直方图上检测峰值
    for (int j = 0; j < xbin2; j++) {
        if (bincontent2[j] > noise_standard2) {
            // 计算峰值边界
        }
    }
}
```

### 2. 精确计算滤波窗口

**目标：** 计算每个峰值的精确起始和结束时间

**窗口合并算法：**

```cpp
// 合并相邻的窗口
if (ppeak2[j + 1] - ppeak2[j] > 2) {  // 间隔大于2 bins
    wwindow.push_back(ppeak2[j]);
    wwindow.push_back(ppeak2[j + 1]);
}

// 合并粗粒度和细粒度的窗口
for (unsigned int j = 0; j < wwindow.size(); j++) {
    window.push_back(wwindow[j]);
}
sort(window.begin(), window.end());

// 合并相邻窗口
if (window[2 * j + 1] - window[2 * j] < 0.95) {  // 小于1个bin
    window1.push_back(window[2 * j]);
    window1.push_back(window[2 * j + 3]);
    j++;  // 跳过下一个窗口
} else {
    window1.push_back(window[2 * j]);
    window1.push_back(window[2 * j + 1]);
}
```

### 3. 生成shield_run{run}.txt文件

**文件格式：**
```
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
```

**示例：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
       ↑主窗口   ↑22ms附近噪声窗口  ↑42ms附近噪声窗口
```

**与步骤3的区别：**
- 步骤3：精度为0.02ms（bin宽度）
- 步骤5：精度为0.005ms（4倍精度）

### 4. 生成ets_cut.txt文件

**合并所有shield文件：**

通过add.sh脚本，将所有run的shield_run*.txt文件合并到ets_cut.txt文件。

**ets_cut.txt文件格式：**
```
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
...
```

**整理后的ets_cut.txt文件：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
65261  0.45  4.15  21.75  22.35  41.45  42.25
...
```

### 5. 生成检查图片

**生成的图片类型：**

1. **run{runNo}_cut.png** - 主要检查图
   - 内容：4个子图（2行×2列）
   - 左上：all_ETS vs hit_TQ_MDC（所有ETS vs MDC响应）
   - 右上：hit_TQ_MDC（MDC响应）
   - 左下：beforeCut_ETS vs hit_TQ_MDC（应用切割前）
   - 右下：afterCut_ETS vs hit_TQ_MDC（应用切割后）

2. **run{runNo}_total.png** - EMC检查图
   - 内容：4个子图（2行×2列）
   - 左上：beforeCut_ETS vs hit_EMC（应用切割前EMC hit数）
   - 右上：beforeCut_ETS vs etot_EMC（应用切割前EMC能量）
   - 左下：afterCut_ETS vs hit_EMC（应用切割后EMC hit数）
   - 右下：afterCut_ETS vs etot_EMC（应用切割后EMC能量）

---

## 四、genJob.sh脚本详解

### 脚本功能

`genJob.sh` 脚本是第五次提交作业的核心，负责：
1. 遍历hist目录下的所有hist文件
2. 为每个run创建作业配置文件
3. 使用hep_sub提交作业到计算集群

### 脚本内容详解

```bash
#!/bin/bash

pwdir=`pwd`
ntuplePath=/besfs5/groups/cal/topup/round${ROUND_NUMBER}/DataValid/hist
str="root"
nfile=0

for file in `/bin/ls ${ntuplePath}/hist*.root`;
do
  length=`expr ${#file} - 10`
  runNo=${file:$length:5}

  echo ${runNo}

  line="${pwdir}/a.out ${ntuplePath} ${runNo} "

  job=plot_ETS_${runNo}.txt

  #if [ -e $job ]; then
  #  echo "info: ${1} exists"
  #  continue
  #fi

  echo "$line" > "${job}"
  sleep 1
  chmod 755 ${job}
  hep_sub -g offlinerun ${job}
  nfile=`expr $nfile + 1`

done

echo "Total = $nfile files"
echo "DONE"
```

### 关键步骤说明

1. **设置工作目录和数据路径：**
   ```bash
   pwdir=`pwd`
   ntuplePath=/besfs5/groups/cal/topup/round${ROUND_NUMBER}/DataValid/hist
   ```
   - `pwdir`：当前工作目录（ETS_cut）
   - `ntuplePath`：hist文件目录，包含第二次提交生成的hist文件

2. **遍历hist文件：**
   ```bash
   for file in `/bin/ls ${ntuplePath}/hist*.root`;
   do
     length=`expr ${#file} - 10`
     runNo=${file:$length:5}
   ```
   - 遍历hist目录下的所有hist*.root文件
   - 从文件名提取run编号（5位数字）
   - 例如：hist85383.root → 85383

3. **创建作业配置文件：**
   ```bash
   line="${pwdir}/a.out ${ntuplePath} ${runNo} "
   job=plot_ETS_${runNo}.txt
   echo "$line" > "${job}"
   chmod 755 ${job}
   ```
   - 作业配置文件格式：`{pwdir}/a.out {ntuplePath} {runNo}`
   - 文件名格式：`plot_ETS_{runNo}.txt`
   - 添加执行权限（755）

4. **提交作业：**
   ```bash
   hep_sub -g offlinerun ${job}
   nfile=`expr $nfile + 1`
   ```
   - 使用hep_sub提交作业
   - 作业组：offlinerun
   - 统计提交的作业数量

5. **输出统计：**
   ```bash
   echo "Total = $nfile files"
   echo "DONE"
   ```
   - 输出提交的作业总数
   - 输出完成标记

### 与步骤3的genJob.sh对比

| 特性 | 步骤3（Search_peak） | 步骤5（ETS_cut） |
|-----|---------------------|------------------|
| **数据源** | hist文件（hist*.root） | hist文件（hist*.root） |
| **提取run号** | 从文件名提取5位 | 从文件名提取5位 |
| **作业配置** | a.out path runNo | a.out path runNo |
| **作业文件名** | run_{runNo}_3.txt | plot_ETS_{runNo}.txt |
| **提交系统** | hep_sub | hep_sub |
| **输出文件** | shield_run*.txt | run{runNo}_cut.png、run{runNo}_total.png、shield_run*.txt |
| **执行时间** | 约10-15分钟 | 约15-20分钟 |

---

## 五、ETS_cut.cpp核心算法详解

### 1. 程序结构

**头文件包含：**
```cpp
#include <stdlib.h>
#include <algorithm>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <vector>
#include "TApplication.h"
#include "TGraph.h"
#include "TGraphErrors.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "RooPlot.h"
#include "TFile.h"
#include "TTree.h"
#include "TStyle.h"
#include "TH1F.h"
#include "TLine.h"
#include "TH2F.h"
#include "TCut.h"
#include "TLatex.h"
```

**ROOT框架：**
- 使用ROOT数据分析框架
- 处理hist文件（ROOT格式）
- 生成直方图和图形

### 2. 主函数：参数解析

```cpp
int main(int argc, char* argv[]){
    int run;
    char path[200];
    if(argc > 2){
        sscanf(argv[1], "%s", path);  // hist文件路径
        sscanf(argv[2], "%d", &run);  // run编号
    } else{
        cout << "too few arguments" << endl;
        return -1;
    }
```

**参数说明：**
- `argv[1]`：hist文件路径（如`/besfs5/groups/cal/topup/round18/DataValid/hist/`）
- `argv[2]`：run编号（如85383）

**调用格式：**
```bash
a.out /besfs5/groups/cal/topup/round18/DataValid/hist/ 85383
```

### 3. 变量定义和文件路径设置

```cpp
    char fname[200];
    char fname1[200];
    char rootname[200];
    char pngname[200];
    char totalname[200];
    int interval = 60;
    char nontopup_cut[200];
    char shieldname[200];

    sprintf(nontopup_cut, "trigChannel_9==0 && !(flag_pre!=21 && (ets1-ets2_pre)/2000>0 && (ets1-ets2_pre)/2000<%d)", interval);

    sprintf(fname, "%s/hist%05d.root", path, run);
    sprintf(fname1, "run%d", run);
    sprintf(rootname, "run%d.root", run);
    sprintf(pngname, "run%d_cut.png", run);
    sprintf(totalname, "run%d_total.png", run);
    sprintf(shieldname, "shield%d.txt", run);

    TFile f(fname);
    TTree* tr = (TTree*)f.Get("event");

    int evt;
    int nhit_TQ_total_mdc;
    int nhit_all_emc;
    double  ets1;
    int trigChannel_9;
    double ets2_pre;
    int  flag_pre;
    double max_ets1 = double(tr->GetMaximum("ets1"));
    int xbin = ceil(max_ets1/2000000);
    double xmin = 0;
    double xmax = max_ets1/2000000 + 0.1*max_ets1/2000000;
    double total_duration = max_ets1/2000000;
```

**关键变量：**

| 变量 | 类型 | 含义 |
|------|------|------|
| interval | int | 注入间隔（60ms） |
| nontopup_cut | char[] | 非topup切割条件 |
| nhit_TQ_total_mdc | int | MDC总命中数 |
| etot_all_emc | double | EMC总能量 |
| ets1 | double | 事件时间戳 |
| ets2_pre | double | 前一次注入时间戳 |
| flag_pre | int | 前置事件标记 |
| trigChannel_9 | int | 触发通道9状态 |
| max_ets1 | double | 最大事件时间戳 |
| xbin | int | bin数量 |
| xmin | double | ΔT最小值（0ms） |
| xmax | double | ΔT最大值（ms） |
| total_duration | double | 总持续时间（ms） |

**文件路径：**
- `fname`：hist文件路径（如`/besfs5/.../hist85383.root`）
- `pngname`：cut图片输出路径（如`run85383_cut.png`）
- `totalname`：total图片输出路径（如`run85383_total.png`）
- `shieldname`：shield文件输出路径（如`shield85383.txt`）

### 4. 绑定变量和创建直方图

```cpp
    tr->SetBranchAddress("nhit_TQ_total_mdc",&nhit_TQ_total_mdc);
    tr->SetBranchAddress("nhit_all_emc",&nhit_all_emc);
    tr->SetBranchAddress("ets1",&ets1);
    tr->SetBranchAddress("evt",&evt);
    tr->SetBranchAddress("trigChannel_9",&trigChannel_9);
    tr->SetBranchAddress("ets2_pre",&ets2_pre);
    tr->SetBranchAddress("flag_pre",&flag_pre);

    TH1F *hh1 = new TH1F("hh1","",xbin,xmin,xmax);
    TH1F *hhh1 = new TH1F("hhh1","",xbin,xmin,xmax);
    TH2F *hh2 = new TH2F("hh2","",xbin,xmin,xmax,2000,0,8000);

    int entries = tr->GetEntries();

    for(int j = 0; j < entries; j++){
        tr->GetEntry(j);

        if(!((ets1-ets2_pre)/2000 > 0 && (ets1-ets2_pre)/2000 < interval && flag_pre != 21)){
            double y = ets1/2000000;
            if(trigChannel_9 == 0){
                hh1->Fill(y,nhit_TQ_total_mdc);
                hhh1->Fill(y,nhit_all_emc);
                if (nhit_TQ_total_mdc > 1000) ppeak1.push_back(y);
            }
        }
    }
```

**填充逻辑：**
- 排除注入期间的事件（0 < ΔT < 60ms）
- 排除随机触发事件（flag_pre != 21）
- 只选择特定触发类型（trigChannel_9 == 0）
- 使用MDC hits作为权重填充直方图
- 记录MDC hits > 1000的事件（用于散点图分析）

### 5. 阶段1：粗粒度寻峰（散点图分析）

```cpp
    sort(ppeak1.begin(), ppeak1.end());

    // 搜索ppeak1（散点图）
    double tmp = 0, countt = 0;
    TCanvas *cc1 = new TCanvas("cc1", "", 300, 200, 900, 600);
    TH1F *t2 = new TH1F("t2", "", 10, 0, 10);

    bool test = false;  // 查看countt分布
    for (unsigned int i = 0; i < ppeak1.size(); i++){
        if (i == 0) tmp = ppeak1[0];
        else{
            if (test) t2->Fill(countt);
            if (ppeak1[i] - tmp < 1){  // bin宽度为1秒
                countt++;
                if (countt == 10){  // 连续10个bin
                    ppeak2.push_back(tmp - 0.1);  // 注意：不能太大
                    ppeak2.push_back(tmp + 1);  // 确保是偶数
                }
            }
            else{
                tmp = ppeak1[i];
                countt = 0;
            }
        }
    }
```

**散点图分析：**
- 记录所有MDC hits > 1000的事件的时间戳
- 检测密集区域（连续10个bin，每个bin1秒）
- 为每个密集区域创建一个粗粒度窗口

### 6. 阶段2：细粒度寻峰（加权直方图分析）

#### 6.1 计算噪声标准

```cpp
    double bincontent1[xbin];
    double sum = 0;
    for (int j = 0; j < xbin; j++){
        bincontent1[j] = hh1->GetBinContent(j + 1);
        if (j < xbin/3) sum = sum + bincontent1[j];  // 只计算前1/3的平均值
    }

    double noise_standard1 = 0;
    double noise_standard2 = 0;

    if (hh1->GetMaximum() > 5*(sum*3/xbin)) noise_standard1 = 3*(sum*3/xbin);  // 动态阈值
    else{
        noise_standard1 = hh1->GetMaximum() + (sum*3/xbin)/2;
        if (ppeak2.size() == 0) NG1 = true;  // 没有检测到密集区域
    }
    if (noise_standard1 < 600000) noise_standard1 = 600000;  // 最小阈值
    cout << "noise_standard1=" << noise_standard1 << endl;
    noise_standard2 = noise_standard1 * 0.005;  // 0.5%噪声标准
    cout << "noise_standard2=" << noise_standard2 << endl;
```

**动态阈值计算：**
```
noise_standard1 = 3 × (前1/3的平均值)  // 如果峰值 > 5×平均值
noise_standard1 = 峰值 + (前1/3的平均值)/2  // 否则
noise_standard2 = noise_standard1 × 0.005  // 0.5%噪声标准
```

#### 6.2 在加权直方图上检测峰值

```cpp
    if (!NG1) {
        for (int j = 0; j < xbin; j++){
            if (bincontent1[j] > noise_standard1){
                int flag = j;
                for (int k = j; k < xbin - 1; k++){
                    if (bincontent[flag + 1] > noise_standard1) flag = flag + 1;
                    else break;
                }
                peak1.push_back(xmin + (xmax - xmin)*j/xbin);  // 峰值起始
                peak1.push_back(xmin + (xmax - xmin)*(flag + 1)/xbin);  // 峰值结束
                j = flag;
            }
        }

        // 计算wwindow（从散点图）
        if (ppeak2.size() != 0){
            wwindow.push_back(ppeak2[0]);
            for (unsigned int j = 1; j < ppeak2.size() - 1; j = j + 2){
                if (ppeak2[j + 1] - ppeak2[j] > 2){  // 间隔大于2 bins
                    wwindow.push_back(ppeak2[j]);
                    wwindow.push_back(ppeak2[j + 1]);
                }
            }
            wwindow.push_back(ppeak2[ppeak2.size() - 1]);
        }

        // 计算window（从加权直方图）
        if (peak1.size() != 0){
            window.push_back(peak1[0]);
            for (unsigned int j = 1; j < peak1.size() - 1; j = j + 2){
                if (peak1[j + 1] - peak1[j] > (xmax - xmin)*5/xbin){  // 间隔大于5 bins
                    window.push_back(peak1[j]);
                    window.push_back(peak1[j + 1]);
                }
            }
            window.push_back(peak1[peak1.size() - 1]);
        }
    }
```

#### 6.3 合并窗口

```cpp
        // 合并wwindow和window
        if (!NG3){
            for (unsigned int j = 0; j < wwindow.size(); j++){
                window.push_back(wwindow[j]);
            }
            sort(window.begin(), window.end());

            // 合并相邻窗口
            if (window.size() != 0){
                for (unsigned int j = 0; j < window.size()/2; j++){
                    if (window[2*j + 1] - window[2*j] < 0.95){  // 小于1个bin
                        window1.push_back(window[2*j]);
                        window1.push_back(window[2*j + 3]);
                        j++;  // 跳过下一个窗口
                    }
                    else{
                        window1.push_back(window[2*j]);
                        window1.push_back(window[2*j + 1]);
                    }
                }
            }
        }

        if (window1.size() == 0) NG1 = true;
        if (window1.size() % 2 != 0 || wwindow.size() % 2 != 0 || window.size() % 2 != 0) { NG5 = true; NG1 = true; }
```

#### 6.4 细粒度分析

```cpp
        // 搜索peak2（细粒度）
        if (!NG1 && !NG3) {
            vector<double> xmin2; xmin2.clear();
            vector<double> xmax2; xmax2.clear();
            for (unsigned int i = 0; i < window1.size() - 1; i = i + 2){
                xmin2.push_back(window1[i]);
                xmax2.push_back(window1[i + 1]);
                count++;
            }

            char hist[50];
            TH1F *h[count];
            for (int i = 0; i < count; i++){
                vector<double> peak2; peak2.clear();
                bool NG2 = false;  // 不画cut线

                sprintf(hist, "h%d", i);
                int xbin2 = (xmax2[i] - xmin2[i]) / 0.005;  // bin宽度为0.005ms

                h[i] = new TH1F(hist, "", xbin2, xmin2[i], xmax2[i]);
                for (int j = 0; j < entries; j++){
                    tr->GetEntry(j);
                    if(!((ets1-ets2_pre)/2000 > 0 && (ets1-ets2_pre)/2000 < 60 && flag_pre != 21)){
                        double y = ets1/2000000;
                        if(trigChannel_9 == 0){
                            h[i]->Fill(y, nhit_TQ_total_mdc);
                        }
                    }
                }

                // 在高精度直方图上检测峰值
                double bincontent2[xbin2];
                for (int j = 0; j < xbin2; j++){
                    bincontent2[j] = h[i]->GetBinContent(j + 1);
                }

                for (int j = 0; j < xbin2; j++){
                    if (bincontent2[j] > noise_standard2){
                        int flag = j;
                        for (int k = j; k < xbin2 - 1; k++){
                            if (bincontent[flag + 1] > noise_standard2) flag = flag + 1;
                            else break;
                        }
                        peak2.push_back(xmin2[i] + (xmax2[i] - xmin2[i])*j/xbin2);
                        peak2.push_back(xmin2[i] + (xmax2[i] - xmin2[i])*(flag + 1)/xbin2);
                        j = flag;
                    }
                }

                if (peak2.size() != 0){
                    window2.push_back(peak2[0]);
                    for (unsigned int j = 1; j < peak2.size() - 1; j = j + 2){
                        if (peak2[j + 1] - peak2[j] > 0.022){  // 间隔大于0.022ms
                            window2.push_back(peak2[j]);
                            window2.push_back(peak2[j + 1]);
                        }
                    }
                    window2.push_back(peak2[peak2.size() - 1]);
                }
                else{
                    NG2 = true;
                }

                if (window2.size() == 0) NG1 = true;
                else NG1 = false;
                if (window2.size() > 70) NG3 = true;
```

#### 6.5 生成shield文件

```cpp
                // 在最后一个循环时生成shield文件
                if (i == count - 1){
                    ofstream fout(shieldname);
                    fout << run;
                    if (!NG3){
                        for (unsigned int j = 0; j < window2.size(); j++){
                            fout << setw(3) << "" << setiosflags(ios::fixed) << setprecision(3) << window2[j];
                        }
                    }
                    else{
                        for (unsigned int j = 0; j < window1.size(); j++){
                            fout << setw(3) << "" << setiosflags(ios::fixed) << setprecision(3) << window1[j];
                        }
                    }
                    fout << endl;

                    // 计算remove_cut
                    if (!NG1){
                        vector<double> xmin3; xmin3.clear();
                        vector<double> xmax3; xmax3.clear();
                        int counttt = 0;
                        if (!NG3){
                            char cut2[window2.size()/2][200];
                            for (unsigned int j = 0; j < window2.size() - 1; j = j + 2){
                                xmin3.push_back(window2[j]);
                                xmax3.push_back(window2[j + 1]);
                                sprintf(cut2[counttt], "!(ets1/2000000>%.3f && ets1/2000000<%.3f)", xmin3[counttt], xmax3[counttt]);
                                counttt++;
                            }
                            for (int j = 0; j < counttt; j++){
                                remove_cut = Form("%s%s%s", remove_cut, connect, cut2[j]);
                            }
                        }
                        else{
                            if (window1.size() <= 70){
                                char cut2[window1.size()/2][200];
                                for (unsigned int j = 0; j < window1.size() - 1; j = j + 2){
                                    xmin3.push_back(window1[j]);
                                    xmax3.push_back(window1[j + 1]);
                                    sprintf(cut2[counttt], "!(ets1/2000000>%.3f && ets1/2000000<%.3f)", xmin3[counttt], xmax3[counttt]);
                                    counttt++;
                                }
                                for (int j = 0; j < counttt; j++){
                                    remove_cut = Form("%s%s%s", remove_cut, connect, cut2[j]);
                                }
                            }
                        }
                    }
                }
```

### 7. 生成检查图片

```cpp
        // 画cut线
        double height_min = h[i]->GetMinimum();
        double height_max = h[i]->GetMaximum();
        TLine *cut[window2.size()];

        if (i < 2){
            c->cd(i*2 + 1);
            h[i]->Draw();
            h[i]->SetFillColor(17);
            h[i]->SetTitle(fname1);
            if (!NG2) h[i]->GetXaxis()->SetTitle("detail_ETS(s)");
            else h[i]->GetXaxis()->SetTitle("noCut_detail_ETS(s)");
            h[i]->GetYaxis()->SetTitle("hit_TQ_MDC");
            h[i]->SetStats(0);

            if (!NG2 && !NG1){
                for (unsigned int j = 0; j < window2.size() - 1; j = j + 2){
                    cut[j] = new TLine(window2[j], height_min, window2[j], height_max);
                    cut[j]->Draw("Same");
                    cut[j]->SetLineWidth(2);
                    cut[j]->SetLineColor(2);
                    cut[j + 1] = new TLine(window2[j + 1], height_min, window2[j + 1], height_max);
                    cut[j + 1]->Draw("Same");
                    cut[j + 1]->SetLineWidth(2);
                    cut[j + 1]->SetLineColor(4);
                }
            }
        }

        cout << "-----------------------------------------" << endl;
        if (NG3){
            for (unsigned int i = 0; i < window1.size() - 1; i = i + 2){
                noise_duration = noise_duration + window1[i + 1] - window1[i];
            }
            cout << "noise duration = " << noise_duration << "(s)" << endl;
        }
        else{
            if (!NG1){
                for (unsigned int i = 0; i < window2.size() - 1; i = i + 2){
                    noise_duration = noise_duration + window2[i + 1] - window2[i];
                }
            }
            cout << "noise duration = " << noise_duration << "(s)" << endl;
        }
        cout << "  cut ratio    = " << noise_duration/total_duration << "%" << endl;
    }

    // c->cd(count + 1);
    c->cd(2);
    hh1->Draw();
    hh1->SetStats(0);
    hh1->SetTitle(fname1);
    hh1->GetXaxis()->SetTitle("all_ETS(s)");
    hh1->GetYaxis()->SetTitle("hit_TQ_MDC");

    c->cd(4);
    hhh1->Draw();
    hhh1->SetStats(0);
    hhh1->SetTitle(fname1);
    hhh1->GetXaxis()->SetTitle("all_ETS(s)");
    hhh1->GetYaxis()->SetTitle("hit_TQ_MDC");

    TCanvas* c2 = new TCanvas ("c2","detail", 300, 200, 1300, 700);
    c2->Divide(2,2);

    c2->cd(2);
    tr->Project("hh2","nhit_TQ_total_mdc:ets1/2000000",nontopup_cut);
    hh2->Draw();
    hh2->SetStats(0);
    hh2->SetTitle(fname1);
    hh2->GetXaxis()->SetTitle("beforeCut_ETS(s)");
    hh2->GetYaxis()->SetTitle("hit_TQ_MDC");

    if (!NG1){
        c2->cd(1);
        TH2F *th1 = new TH2F("th1","",xbin,xmin,xmax, 500, 0, 8500);
        tr->Project("th1","nhit_TQ_total_mdc:ets1/2000000",remove_cut);
        th1->Draw();
        th1->SetStats(0);
        th1->SetTitle(fname1);
        th1->GetXaxis()->SetTitle("afterCut_ETS(s)");
        th1->GetYaxis()->SetTitle("hit_TQ_MDC");
    }

    c2->cd(4);
    TH2F *th3 = new TH2F("th3","",xbin,xmin,xmax, 500, 0, 8500);
    tr->Project("th3","nhit_all_emc:ets1/2000000",basic_cut);
    th3->Draw();
    th3->SetStats(0);
    th3->SetTitle(fname1);
    th3->GetXaxis()->SetTitle("beforeCut_ETS(s)");
    th3->GetYaxis()->SetTitle("hit_EMC");

    if (!NG1) {
        c2->cd(3);
        TH2F *th4 = new TH2F("th4","",xbin,xmin,xmax, 500, 0, 8500);
        tr->Project("th4","nhit_all_emc:ets1/2000000",remove_cut);
        th4->Draw();
        th4->SetStats(0);
        th4->SetTitle(fname1);
        th4->GetXaxis()->SetTitle("afterCut_ETS(s)");
        th4->GetYaxis()->SetTitle("hit_EMC");
    }

    TLatex* a1 = new TLatex();
    a1->SetNDC(1);
    a1->SetTextSize(0.1);
    a1->DrawLatex(0.15, 0.015, fname1);

    if (NG3 || NG5){
        TLatex* a2 = new TLatex();
        a2->SetNDC(1);
        a2->SetTextSize(0.1);
        a2->SetTextColor(2);
        a2->DrawLatex(0.7, 0.7, "abnormal");
        if (NG3){
            TLatex* a3 = new TLatex();
            a3->SetNDC(1);
            a3->SetTextSize(0.1);
            a3->SetTextColor(2);
            a3->DrawLatex(0.55, 0.5, "Too many windows");
        }
        else{
            TLatex* a3 = new TLatex();
            a3->SetNDC(1);
            a3->SetTextSize(0.1);
            a3->SetTextColor(2);
            a3->DrawLatex(0.55, 0.5, "window.size() is odd");
        }
    }

    if (!NG1) {
        c2->SaveAs(rootname);
    }
    c->Print(pngname);
    c2->Print(totalname);

    delete hh1;
    delete hhh1;
    f.Close();

    return 0;
}
```

### 8. 输出结果

**输出文件：**
1. `run{runNo}_cut.png` - 主要检查图
2. `run{runNo}_total.png` - EMC检查图
3. `run{runNo}.root` - 详细图文件
4. `shield_run{runNo}.txt` - 窗口参数文件

---

## 六、步骤5的子步骤详解

### 步骤5.1：第五次作业提交并检查cut和all文件（合并版）

**功能：**
- 删除旧文件（plot*和run*）
- 提交作业（可选submit_job参数）
- 检查cut和all文件
- 定时检查所有run完成

**关键特性：**

1. **submit_job参数：**
   - 如果`submit_job=True`（默认）：先提交作业，然后检查cut和all文件
   - 如果`submit_job=False`：跳过作业提交，直接检查cut和all文件

2. **删除旧文件：**
   ```bash
   rm -f plot* run*
   ```
   - 删除以plot开头的文件
   - 删除以run开头的文件
   - 确保每次执行都是干净的状态

3. **阶段1：提交作业（仅当submit_job=True）：**
   - 执行`cd {ETS_CUT_DIR} && source {ENV_SCRIPT} && ./genJob.sh`
   - 检查生成的作业文件（plot_ETS_*.txt）
   - 输出作业文件列表

4. **阶段2：检查cut和all文件：**
   - 获取作业文件列表，提取run号
   - 定期检查以下文件：
     - `run{runNo}_cut.png`
     - `run{runNo}_total.png`
   - 默认等待25分钟，每30秒检查一次
   - 支持通过参数自定义等待时间

5. **定时检查：**
   - 每次检查所有未完成的run号
   - 显示检查进度
   - 记录已完成和未完成的run号

6. **返回结果：**
   - 如果所有cut和all文件都生成，返回成功
   - 如果超时，返回未完成的run号列表

**示例运行：**

```bash
# 方法1：提交作业并检查（默认）
python run.py --step 5.1 --date 250519

# 方法2：只检查，不提交作业
python run.py --step 5.1 --date 250519 --submit-job false

# 方法3：自定义等待时间
python run.py --step 5.1 --date 250519 --max-wait 30
```

### 步骤5.2：运行add_shield.sh脚本

**功能：**
- 进入ETS_cut目录
- 执行add.sh脚本
- 合并所有shield_run*.txt文件
- 生成ets_cut.txt文件

**执行命令：**
```bash
cd {ETS_CUT_DIR} && ./add.sh
```

**add.sh脚本内容：**
```bash
cat shield*.txt >> ets_cut.txt
```

**输出：**
- ets_cut.txt文件（包含所有run的ETS切割参数）

**示例运行：**

```bash
python run.py --step 5.2
```

### 步骤5.3：整理ets_cut.txt文件

**功能：**
- 删除单数字行
- 按run号排序
- 删除重复行

**执行的命令：**

**步骤1：删除单数字行**
```bash
grep -vE '^[0-9]+$' ets_cut.txt > ets_cut_temp.txt && mv ets_cut_temp.txt ets_cut.txt
```

**步骤2：按run号排序**
```bash
sort -n -k1,1 ets_cut.txt > ets_cut_temp.txt && mv ets_cut_temp.txt ets_cut.txt
```

**步骤3：删除重复行**
```bash
uniq ets_cut.txt > ets_cut_temp.txt && mv ets_cut_temp.txt ets_cut.txt
```

**说明：**
- `grep -vE '^[0-9]+$'`：删除只包含数字的行
- `sort -n -k1,1`：按第一列（run号）数字排序
- `uniq`：删除连续的重复行

**示例运行：**

```bash
python run.py --step 5.3
```

### 步骤5.4：合并图片

**功能：**
- 进入ETS_cut目录
- 在SL6容器中执行ImageMagick的convert命令
- 将所有PNG图片合并为PDF
- 通过SFTP下载PDF文件到本地

**执行的命令：**
```bash
cd {ETS_CUT_DIR} && /cvmfs/container.ihep.ac.cn/bin/hep_container shell SL6 << 'EOF'
convert *.png mergedd_ETSCut.pdf
exit
EOF
```

**技术细节：**

1. **容器环境：**
   - 使用`/cvmfs/container.ihep.ac.cn/bin/hep_container shell SL6`进入SL6容器
   - 容器中预装了ImageMagick工具

2. **图片合并：**
   - 使用`convert *.png mergedd_ETSCut.pdf`命令
   - 按文件名顺序合并所有PNG图片
   - 输出文件名为`mergedd_ETSCut.pdf`

3. **文件下载：**
   - 使用SFTP协议下载PDF文件
   - 保存到本地`downloads/`目录
   - 文件名格式：`mergedd_ETSCut_{date}.pdf`

**下载路径：**
- 远程：`{ETS_CUT_DIR}/mergedd_ETSCut.pdf`
- 本地：`{LOCAL_DOWNLOAD_DIR}/mergedd_ETSCut_{date}.pdf`
- 默认本地目录：`C:\Users\孟皇薪\Desktop\topup\downloads\`

**示例运行：**

```bash
python run.py --step 5.4 --date 250519
```

---

## 七、ets_cut.txt文件格式详解

### 文件结构

**格式：**
```
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
...
```

**示例：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
65261  0.45  4.15  21.75  22.35  41.45  42.25
```

### 字段说明

| 字段 | 含义 | 单位 | 示例 |
|------|------|------|------|
| runNo | run编号 | - | 65260 |
| peak1_start | 第1个峰值起始时间 | 毫秒 | 0.50 |
| peak1_end | 第1个峰值结束时间 | 毫秒 | 4.20 |
| peak2_start | 第2个峰值起始时间 | 毫秒 | 21.80 |
| peak2_end | 第2个峰值结束时间 | 毫秒 | 22.40 |
| ... | 更多峰值 | 毫秒 | ... |

### 预期窗口数量

**标准情况（1主窗口 + 3噪声窗口）：**

```
65260  0.50  4.20  21.80  22.40  41.50  42.30
       ↑主窗口   ↑22ms附近噪声  ↑42ms附近噪声
```

**与步骤3的对比：**

| 特性 | 步骤3（Search_peak） | 步骤5（ETS_cut） |
|------|---------------------|------------------|
| **bin宽度** | 0.02ms | 0.005ms |
| **精度** | 中等 | 高（4倍） |
| **阈值计算** | 2.7倍超出平均值 | 5%噪声标准 |
| **峰值识别** | 单阶段 | 两阶段 |
| **窗口合并** | 固定逻辑 | 智能合并 |

---

## 八、第五次提交作业在离线事件滤波器中的作用

### 数据流程图

```
第二次提交作业生成的hist文件
    ↓
[步骤5.1：第五次作业提交]
    ├─ 删除旧文件（plot*和run*）
    ├─ 提交寻峰作业（可选submit_job参数）
    │  ├─ 读取hist文件
    │  ├─ 阶段1：粗粒度寻峰（散点图分析）
    │  ├─ 阶段2：细粒度寻峰（加权直方图）
    │  ├─ 合并窗口
    │  ├─ 细粒度分析（bin宽度0.005ms）
    │  ├─ 生成shield_run{runNo}.txt
    │  └─ 生成检查图片（cut和total）
    └─ 检查cut和all文件
       ├─ 获取run号列表
       ├─ 定期检查文件生成
       └─ 返回完成状态
    ↓
shield_run*.txt文件（每个run的ETS切割参数）
    ↓
[步骤5.2：运行add.sh脚本]
    ├─ 合并所有shield文件
    └─ 生成ets_cut.txt
    ↓
ets_cut.txt文件（初步格式）
    ↓
[步骤5.3：整理ets_cut.txt文件]
    ├─ 删除单数字行
    ├─ 按run号排序
    └─ 删除重复行
    ↓
ets_cut.txt文件（整理后）
    ↓
[步骤5.4：合并图片]
    ├─ 合并所有cut和total图片
    └─ 下载到本地
    ↓
mergedd_ETSCut_{date}.pdf
    ↓
[步骤6：第六次作业]
    ├─ 应用ETS切割参数
    ├─ 生成最终检查图片
    └─ 验证滤波效果
    ↓
[步骤7：提交数据库]
    └─ 将滤波器参数保存到数据库
    ↓
在事件重建时应用滤波器
```

### 物理意义

通过两阶段算法精确识别MDC响应中的背景峰值，步骤5.1-5.4为离线事件滤波器提供了：
- 需要过滤的时间窗口（主窗口，高精度）
- 噪声源的标记（噪声窗口，高精度）
- 滤波器参数的精确估计（4倍精度）

这是实现离线事件滤波器的核心算法优化，直接决定了滤波器的性能。

### 与论文的对应

步骤5.1-5.4对应论文中图4的 **"MDC和EMC响应 vs ΔT分布"** 精确分析部分，以及图5的 **"精确滤波窗口确定"** 部分。

---

## 九、示例：run65260的完整流程

### 1. hist文件

```bash
/besfs5/groups/cal/topup/round18/DataValid/hist/hist65260.root
```

**内容：**
- TTree对象：event
- 关键变量：nhit_TQ_total_mdc, ets1, ets2_pre, flag_pre, trigChannel_9, etot_all_emc, nhit_all_emc

### 2. 作业配置文件（plot_ETS_65260.txt）

```bash
/besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/ETS_cut/a.out /besfs5/groups/cal/topup/round18/DataValid/hist 65260
```

**说明：**
- 执行路径：ETS_cut/a.out
- hist文件路径：/besfs5/.../hist/
- run编号：65260

### 3. 输出文件

**shield_run65260.txt：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
```

**说明：**
- run编号：65260
- 主窗口：0.50ms - 4.20ms（宽度3.70ms）
- 噪声窗口1：21.80ms - 22.40ms（宽度0.60ms，22ms附近）
- 噪声窗口2：41.50ms - 42.30ms（宽度0.80ms，42ms附近）

**run65260_cut.png：**
- 4个子图（2行×2列）
- 显示MDC响应和滤波窗口

**run65260_total.png：**
- 4个子图（2行×2列）
- 显示EMC响应和滤波窗口

### 4. ets_cut.txt文件

**内容：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
65261  0.45  4.15  21.75  22.35  41.45  42.25
...
```

**说明：**
- 所有run的ETS切割参数
- 每行对应一个run
- 每个run有1个主窗口和多个噪声窗口
- 精度为0.005ms（4倍于步骤3）

---

## 十、常见问题和解决方法

### 问题1：作业提交失败

**症状：**
```
执行genJob.sh脚本失败
```

**原因：**
- hist文件不存在
- 环境变量未设置
- 权限不足

**解决方法：**
- 检查hist文件是否存在：`ls /besfs5/.../hist/hist*.root`
- 检查环境变量：`echo $ROUND_NUMBER`
- 检查权限：`ls -la genJob.sh`

### 问题2：cut和all文件检查超时

**症状：**
```
在 25 分钟内未完成所有cut和all文件的生成
```

**原因：**
- 计算集群负载高
- run数量多
- 网络问题

**解决方法：**
- 增加等待时间：`python run.py --step 5.1 --date 250519 --max-wait 30`
- 检查作业状态：`hep_q -u topup`
- 重新提交失败的作业

### 问题3：窗口数量异常

**症状：**
```
ets_cut.txt中的窗口数量不符合预期（1主窗口 + 3噪声窗口）
```

**原因：**
- 噪声水平过高
- 寻峰算法参数不合适
- 数据质量问题

**解决方法：**
- 检查详细的run{runNo}.root图文件
- 调整寻峰算法参数（noise_standard等）
- 手动审核数据质量

### 问题4：ets_cut.txt文件为空

**症状：**
```
ets_cut.txt文件没有内容或只有少量run
```

**原因：**
- 所有run都是非topup运行
- shield文件未正确生成
- add.sh脚本执行失败

**解决方法：**
- 检查interval.txt确认run的注入模式
- 检查shield_run*.txt文件是否存在
- 手动执行add.sh脚本：`cd ETS_cut && ./add.sh`

### 问题5：图片合并失败

**症状：**
```
执行图片合并失败
```

**原因：**
- 容器环境问题
- ImageMagick未安装
- 磁盘空间不足

**解决方法：**
- 检查容器是否正常
- 检查ImageMagick是否可用
- 检查磁盘空间

---

## 十一、总结

### 第五次提交作业的本质

第五次提交作业是 **BESIII离线事件滤波器校准流程中的ETS切割确定阶段**，其核心任务是：

1. **粗粒度寻峰**：使用散点图分析识别潜在峰值区域
2. **细粒度寻峰**：使用加权直方图精确计算峰值边界（bin宽度0.005ms）
3. **窗口合并**：智能合并相邻窗口，避免重复
4. **生成shield文件**：保存每个run的ETS切割参数
5. **生成ets_cut.txt文件**：保存所有run的ETS切割参数
6. **生成检查图片**：用于人工审核和验证

### 关键技术点

1. **genJob.sh脚本**：自动化作业生成和提交
2. **ETS_cut.cpp**：两阶段寻峰算法（粗粒度+细粒度）
3. **散点图分析**：识别密集区域（MDC hits > 1000）
4. **高精度直方图**：bin宽度为0.005ms（4倍精度）
5. **窗口合并算法**：智能合并相邻窗口
6. **定时检查机制**：确保作业完成
7. **add.sh脚本**：合并所有run的结果
8. **ets_cut.txt整理**：删除单数字行、排序、去重
9. **SFTP下载**：自动下载PDF文件

### 物理意义

通过两阶段算法精确识别MDC响应中的背景峰值，步骤5.1-5.4为：
- 识别注入背景污染事件（高精度）
- 确定最优滤波窗口（高精度）
- 提高数据质量
- 保证物理结果的可靠性

提供了关键的ETS切割参数（4倍精度于步骤3）。

### 算法参数总结

| 参数 | 值 | 物理意义 |
|------|---|---------|
| interval | 60 | topup注入周期（ms） |
| bin宽度（粗粒度） | 0.02ms | hist文件的bin宽度 |
| bin宽度（细粒度） | 0.005ms | 高精度bin宽度（4倍） |
| 散点图阈值 | 1000 | MDC hits阈值 |
| 散点图bin宽度 | 1s | 散点图bin宽度 |
| 散点图连续bin数 | 10 | 连续bin阈值 |
| 噪声标准1 | 动态计算 | 粗粒度噪声标准 |
| 噪声标准2 | noise_standard1 × 0.005 | 细粒度噪声标准（0.5%） |
| 窗口合并阈值 | 0.95ms | 小于1个bin则合并 |
| 细粒度间隔阈值 | 0.022ms | 间隔大于0.022ms则分离 |
| 最小峰值宽度 | 0.005ms | 细粒度最小精度 |

### 与步骤3的对比总结

| 特性 | 步骤3（Search_peak） | 步骤5（ETS_cut） |
|------|---------------------|------------------|
| **bin宽度** | 0.02ms | 0.005ms（4倍精度） |
| **算法阶段** | 单阶段 | 两阶段（粗粒度+细粒度） |
| **峰值识别** | 阈值检测 | 散点图+高精度直方图 |
| **阈值计算** | 2.7倍超出平均值 | 5%噪声标准 |
| **窗口合并** | 固定逻辑 | 智能合并 |
| **输出精度** | 0.02ms | 0.005ms |
| **检查图片** | 1张（run{runNo}.root） | 2张（cut和total） |
| **执行时间** | 约10-15分钟 | 约15-20分钟 |

### 未来改进方向

1. **优化寻峰算法：**
   - 尝试不同的散点图阈值
   - 改进窗口合并逻辑
   - 提高噪声抑制能力

2. **支持多种注入模式：**
   - 自动识别不同的注入模式
   - 动态调整算法参数
   - 支持混合模式数据处理

3. **增强异常检测：**
   - 添加更多数据质量检查
   - 实现更智能的异常识别
   - 提供更详细的错误诊断

4. **改进可视化：**
   - 生成更详细的检查图片
   - 添加峰值标记和注释
   - 支持交互式审核

---

## 附录A：相关文件路径

### 远程服务器路径

```
/besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/ETS_cut/  # 工作目录
/besfs5/groups/cal/topup/round18/DataValid/hist/                            # hist文件目录
/besfs5/groups/cal/topup/round18/DataValid/InjSigTimeCal/                    # interval.txt目录
```

### 本地路径

```
C:\Users\孟皇薪\Desktop\topup\downloads\                    # 下载目录
C:\Users\孟皇薪\Desktop\topup\logs\                         # 日志目录
C:\Users\孟皇薪\Desktop\topup\.step_progress                # 进度文件
```

---

## 附录B：命令参考

### 执行步骤

```bash
# 执行单个步骤（提交作业并检查）
python run.py --step 5.1 --date 250519

# 执行单个步骤（只检查，不提交作业）
python run.py --step 5.1 --date 250519 --submit-job false

# 执行单个步骤（自定义等待时间）
python run.py --step 5.1 --date 250519 --max-wait 30

# 执行步骤5.2
python run.py --step 5.2

# 执行步骤5.3
python run.py --step 5.3

# 执行步骤5.4
python run.py --step 5.4 --date 250519

# 执行所有步骤
python run.py --all --date 250519

# 从断点继续
python run.py --continue
```

### 查看作业状态

```bash
# 查看topup用户的作业
hep_q -u topup -g offlinerun

# 查看具体作业详情
hep_q -j <job_id>
```

### 手动操作

```bash
# 进入ETS_cut目录
cd /besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/ETS_cut

# 删除旧文件
rm -f plot* run*

# 提交作业
./genJob.sh

# 查看作业文件
ls plot_ETS_*.txt

# 查看shield文件
ls shield_run*.txt

# 查看cut和total图片
ls run*_cut.png run*_total.png

# 合并shield文件
./add.sh

# 查看ets_cut.txt
cat ets_cut.txt

# 整理ets_cut.txt
grep -vE '^[0-9]+$' ets_cut.txt > ets_cut_temp.txt && mv ets_cut_temp.txt ets_cut.txt
sort -n -k1,1 ets_cut.txt > ets_cut_temp.txt && mv ets_cut_temp.txt ets_cut.txt
uniq ets_cut.txt > ets_cut_temp.txt && mv ets_cut_temp.txt ets_cut.txt

# 进入SL6容器
/cvmfs/container.ihep.ac.cn/bin/hep_container shell SL6

# 合并图片
convert *.png mergedd_ETSCut.pdf

# 退出容器
exit
```

---

## 附录C：术语表

| 术语 | 英文 | 含义 |
|------|------|------|
| IST | Injection Signal Time Stamp | 注入信号时间戳 |
| ETS | Event Time Stamp | 事件时间戳 |
| ΔT | Delta Time | 事件与注入的时间差 |
| MDC | Main Drift Chamber | 主漂移室 |
| EMC | Electromagnetic Calorimeter | 电磁量能器 |
| topup | top-up injection | 顶部注入 |
| ROOT | ROOT Data Analysis Framework | ROOT数据分析框架 |
| shield | shield window | 滤波窗口 |
| peak | peak | 峰值 |
| threshold | threshold | 阈值 |
| noise standard | noise standard | 噪声标准 |
| ETS cut | ETS cut | ETS切割参数 |
| scatter plot | scatter plot | 散点图 |
| weighted histogram | weighted histogram | 加权直方图 |

---

**文档创建时间：** 2026年2月21日
**基于论文：** "Suppression of top-up injection backgrounds with offline event filter in the BESIII experiment" (Radiation Detection Technology and Methods, 2022)
**基于代码：** genJob.sh, ETS_cut.cpp, add.sh, step5_1_fifth_job_submission.py, step5_2_run_add_shield_script.py, step5_3_organize_ets_cut_file.py, step5_4_merge_images.py
**基于操作手册：** 步骤18-21
**作者：** iFlow CLI