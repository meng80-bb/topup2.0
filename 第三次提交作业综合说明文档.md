# 第三次提交作业综合说明文档

## 文档说明

本文档详细说明了BESIII离线事件滤波器校准流程中**第三次提交作业**（步骤3.1-3.2）的目的、意义、技术实现和物理背景。

**目标读者：** 新用户、需要了解项目背景的开发者、iFlow CLI参考文档

**相关文件：**
- 步骤3.1：`step3_1_third_job_submission.py` - 第三次作业提交并检查shield文件（合并版）
- 步骤3.2：`step3_2_run_add_script.py` - 运行add.sh脚本
- 操作手册：`A-topup操作.docx`
- 论文：`OfflineEventFilter_rdtm2022.pdf`

---

## 一、第三次提交作业概述

### 什么是第三次提交作业？

第三次提交作业是BESIII离线事件滤波器校准流程的**关键转折点**，其核心任务是分析第二次提交作业生成的histogram文件，在MDC响应分布中识别背景峰值，计算滤波窗口的起始和结束时间，并生成window.dat文件，为后续的滤波器应用提供精确的参数。

### 在整个流程中的位置

第三次提交作业对应论文图5所示的离线数据处理流程中的 **"峰值识别与窗口确定"** 环节，是从"物理响应分析"到"滤波器参数确定"的关键过渡步骤。

### 步骤3的子步骤关系

步骤3包含2个子步骤，形成一个完整的峰值识别和窗口生成流程：

```
步骤3.1：第三次作业提交（核心）
    ├─ 提交寻峰作业
    ├─ 检查shield文件
    └─ 定时检查所有run完成
    ↓
步骤3.2：运行add.sh脚本
    ├─ 合并所有shield_run*.txt文件
    └─ 生成window.dat文件
```

**说明：**
- **步骤3.1**是核心，负责提交寻峰作业并检查shield文件生成
- **步骤3.2**负责合并所有run的结果，生成最终的window.dat文件
- 两个步骤共同完成从histogram数据到滤波窗口参数的转换

### 与前两次提交作业的区别

| 对比项 | 第一次提交作业 | 第二次提交作业 | 第三次提交作业 |
|-------|--------------|--------------|--------------|
| **输入数据** | 原始数据（*.raw文件） | 第一次提交的ROOT文件 | 第二次提交的hist文件 |
| **输出文件** | InjSigTime文件、Interval文件 | hist*.root、check*.png | shield_run*.txt、window.dat |
| **核心算法** | GetRawETS、GetTIntervalAlg | ResetEtsAlg、OfflineEvtFilterCalibAlg | Search_peak.cpp（寻峰算法） |
| **物理意义** | 提取时间戳（IST和ETS）、计算ΔT | 分析探测器响应与ΔT的关系 | 识别背景峰值，确定滤波窗口 |
| **后续用途** | 计算ΔT = ETS - IST | 识别背景峰值 | 应用滤波窗口到事件 |
| **关键输出** | interval.txt（注入间隔） | histogram文件 | window.dat（滤波窗口参数） |

---

## 二、第三次提交作业的物理背景

### 研究背景：BEPCII顶部注入（Top-up Injection）

**BEPCII于2019年底实现了顶部注入（top-up injection）：**
- 时间平均积分亮度提高了约30%
- 但频繁的束流注入在数据采集期间造成了明显的注入背景
- 这些背景严重影响了数据质量和物理结果的可靠性

### 核心问题：注入背景污染

**注入背景特征：**

1. **MDC（主漂移室）响应：**
   - 暗电流在注入期间增加约2倍
   - MDC几乎完全被占满，导致径迹重建困难
   - 对束流相关背景最敏感（最靠近束流管）
   - 论文图4a显示：在ΔT很小（0-10ms）时，MDC占用率可达60%以上（4000+ hits）

2. **EMC（电磁量能器）响应：**
   - 总能量沉积可达1000 GeV以上
   - 远高于质心对撞能量（约2.0 GeV）
   - 对束流相关背景也很敏感
   - 论文图4b显示：在ΔT很小时，EMC能量沉积可达200 GeV以上

**峰值出现的物理原因：**
- **注入瞬间**：束流注入时产生大量次级粒子
- **瞬时背景**：这些次级粒子在探测器中产生大量信号
- **时间集中**：背景主要发生在注入后的短时间内（0-10ms）
- **能量沉积**：导致MDC和EMC响应急剧增加

### 解决方案：离线事件滤波器（Offline Event Filter）

**离线事件滤波器的作用：**
1. **背景峰值识别：** 基于MDC和EMC的响应识别严重背景污染时期
2. **时间差计算：** 计算 ΔT = ETS - IST（事件相对于注入的时间）
3. **滤波窗口确定：** 使用MDC和EMC的平均占用率和总能量沉积分布确定滤波窗口
4. **事件过滤：** 在事件重建前，离线事件滤波器算法访问数据库，决定保留或跳过每个事件

**应用效果：**
- 有效去除被注入背景污染的数据
- 显著改善数据质量
- 保持最佳数据采集效率
- 有助于避免蒙特卡罗模拟与数据之间的不一致性

### 寻峰算法的必要性

根据论文第4节和图4，在ΔT很小（0-10ms）时，MDC和EMC响应出现明显的峰值。这些峰值表示：

1. **主峰**：对应注入期间的主要背景污染（ΔT ≈ 0-5ms）
2. **噪声峰**：可能对应其他干扰源（如50Hz电源噪声）

**寻峰算法的目标：**
- 识别所有显著的峰值
- 计算每个峰值的起始和结束时间
- 区分主峰和噪声峰
- 生成滤波窗口参数

---

## 三、第三次提交作业的核心目标

### 1. 读取第二次提交的hist文件

**读取hist*.root文件：**

- 从`/besfs5/groups/cal/topup/round18/DataValid/hist/`目录读取hist文件
- 每个run对应一个hist文件（hist{run}.root）
- hist文件包含MDC和EMC响应与ΔT的关系

### 2. 执行寻峰算法

**Search_peak.cpp核心功能：**

1. **读取hist文件**：提取MDC和EMC响应数据
2. **读取interval.txt**：判断是否为非topup运行
3. **创建直方图**：
   - h[0]：MDC响应 vs ΔT分布
   - h[1]：EMC hit数 vs ΔT分布
   - h[2]：EMC能量 vs ΔT分布
4. **寻峰算法**：
   - 计算噪声标准（平均值）
   - 检测显著高于噪声的峰值
   - 计算峰值的参数（起始、结束、阈值）
   - 扩展峰值边界
   - 过滤窄峰（噪声）
5. **输出结果**：生成shield_run{run}.txt文件

### 3. 识别背景峰值

**峰值识别标准：**

Search_peak.cpp使用自适应阈值算法识别峰值：

1. **条件1**：bin内容 > 噪声标准（平均值）
2. **条件2**：bin内容 > 前一个bin×10 且 bin内容 > 4000

满足任一条件即认为检测到峰值。

**峰值参数计算：**

- **背景水平（mean）**：在峰值前50-70个bin处计算平均值
- **初步阈值（threshold）**：峰值附近数据与平均值的平均偏差
- **最终阈值**：2.7倍超出mean部分的平均值（特殊情况：mean=0时使用1500）
- **峰值起始（flag2）**：峰值开始上升的位置
- **峰值结束（flag1）**：峰值下降到背景水平的位置

### 4. 生成shield_run{run}.txt文件

**文件格式：**
```
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
```

**示例：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
       ↑主窗口   ↑22ms附近噪声窗口  ↑42ms附近噪声窗口
```

**物理意义：**
- 每个峰值由起始和结束两个时间值组成（单位：毫秒）
- 主窗口对应注入期间的主要背景污染
- 噪声窗口对应其他干扰源（如50Hz电源噪声）

### 5. 生成window.dat文件

**合并所有shield文件：**

通过add.sh脚本，将所有run的shield_run*.txt文件合并到window.dat文件。

**window.dat文件格式：**
```
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
...
```

**预期窗口数量：**
- **1个主窗口**：对应注入期间的主要背景峰值（ΔT ≈ 0-5ms）
- **3个噪声窗口**：对应不同频率的噪声

**可能的噪声窗口：**
- 2Hz噪声（周期500ms）
- 20Hz噪声（周期50ms）
- 40Hz噪声（周期25ms）
- 50Hz噪声（周期20ms，电源噪声）

---

## 四、genJob.sh脚本详解

### 脚本功能

`genJob.sh` 脚本是第三次提交作业的核心，负责：
1. 遍历hist目录下的所有hist文件
2. 为每个run创建作业配置文件
3. 使用hep_sub提交作业到计算集群

### 脚本内容详解

```bash
#!/bin/bash

pwdir=`pwd`
ntuplePath=/besfs5/groups/cal/topup/round${ROUND_NUMBER}/DataValid/hist/
str="root"
nfile=0

for file in `/bin/ls ${ntuplePath}/hist*.root`;
do
  length=`expr ${#file} - 10`
  # echo "length" $length
  runNo=${file:$length:5}

  echo ${runNo}

  line="${pwdir}/a.out ${ntuplePath} ${runNo} "

  job=run_${runNo}_3.txt

  #if [ -e $job ]; then
  #  echo "info: ${1} exists"
  #  continue
  #fi

  echo "$line" >> "${job}"
  chmod +x ${job}
  hep_sub -g offlinerun ${job}
  nfile=`expr $nfile + 1`

done

echo "Total = $nfile files"
echo "DONE"
```

### 关键步骤说明

1. **设置工作目录和数据路径：**
   ```bash
   pwdir=`pwd`
   ntuplePath=/besfs5/groups/cal/topup/round${ROUND_NUMBER}/DataValid/hist/
   ```
   - `pwdir`：当前工作目录（search_peak）
   - `ntuplePath`：hist文件目录，包含第二次提交生成的hist文件

2. **遍历hist文件：**
   ```bash
   for file in `/bin/ls ${ntuplePath}/hist*.root`;
   do
     length=`expr ${#file} - 10`
     runNo=${file:$length:5}
   ```
   - 遍历hist目录下的所有hist*.root文件
   - 从文件名提取run编号（5位数字）
   - 例如：hist85383.root → 85383

3. **创建作业配置文件：**
   ```bash
   line="${pwdir}/a.out ${ntuplePath} ${runNo} "
   job=run_${runNo}_3.txt
   echo "$line" >> "${job}"
   chmod +x ${job}
   ```
   - 作业配置文件格式：`{pwdir}/a.out {ntuplePath} {runNo}`
   - 文件名格式：`run_{runNo}_3.txt`
   - 添加执行权限

4. **提交作业：**
   ```bash
   hep_sub -g offlinerun ${job}
   nfile=`expr $nfile + 1`
   ```
   - 使用hep_sub提交作业
   - 作业组：offlinerun
   - 统计提交的作业数量

5. **输出统计：**
   ```bash
   echo "Total = $nfile files"
   echo "DONE"
   ```
   - 输出提交的作业总数
   - 输出完成标记

### 与第一次和第二次提交作业的genJob.sh对比

| 特性 | 第一次提交 | 第二次提交 | 第三次提交 |
|-----|----------|----------|----------|
| **数据源** | 原始数据（*.raw） | ROOT文件（InjSigTime） | hist文件（hist*.root） |
| **提取run号** | 从文件名提取6位 | 从目录名提取5位 | 从文件名提取5位 |
| **作业配置** | 使用temp.txt模板 | 使用temp.txt模板 | 简单格式：a.out path runNo |
| **提交系统** | boss.condor | boss.condor | hep_sub |
| **输出文件** | InjSigTime文件 | hist文件 | shield_run*.txt文件 |
| **执行时间** | 约10-20分钟 | 约20-30分钟 | 约10-15分钟 |

---

## 五、Search_peak.cpp核心算法详解

### 1. 程序结构

**头文件包含：**
```cpp
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <vector>
#include "TGraph.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "RooPlot.h"
#include "TFile.h"
#include "TTree.h"
#include "TStyle.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TCut.h"
#include "TMath.h"
#include "TSpectrum.h"
#include "TList.h"
#include "TPolyMarker.h"
#include "TApplication.h"
```

**ROOT框架：**
- 使用ROOT数据分析框架
- 处理hist文件（ROOT格式）
- 生成直方图和图形

### 2. 辅助函数：合并数组并去重

```cpp
double *merged_remove_repetition_array(double *a,double *b,double *c){
  int size_a = 20;
  int size_b = 20;
  int size_c = 20;
  int size = size_a+size_b+size_c;

  double add_array[size];
  double *remove_repetition = new double[size];

  for(int i=0;i<size;i++){
    add_array[i]=0;
    remove_repetition[i]=0;
  }

  int num=0;
  for(int i=0;i<size;i++){
    if(i<size_a) add_array[i]=a[i];
    else if(i<size_a+size_b) add_array[i]=b[i-size_a];
    else if(i<size) add_array[i]=c[i-size_a-size_b];
  }

  for(int j=0;j<size;j++){
    bool flagtmp=true;
    if(add_array[j]==0) continue;
    for(int k=j+1;k<size;k++){
      if(add_array[j]==add_array[k]) {
        flagtmp = false;
      }
    }
    if(flagtmp){
      remove_repetition[num]=add_array[j];
      num++;
    }
  }

  return remove_repetition;
}
```

**功能：**
- 合并三个数组（a、b、c）
- 去除重复值
- 返回去重后的数组

**用途：**
- 可能用于合并不同探测器（MDC、EMC）的峰值信息
- 确保峰值列表的唯一性

### 3. 主函数：参数解析

```cpp
int main(int argc, char* argv[]){
  // 设置ROOT绘图风格
  gStyle->SetPadLeftMargin(0.2);
  gStyle->SetPadBottomMargin(0.2);
  gStyle->SetPadRightMargin(0.2);
  gStyle->SetPadTopMargin(0.05);
  gStyle->SetFrameLineWidth(2);
  gStyle->SetFrameLineWidth(2);
  gStyle->SetCanvasColor(10);
  gStyle->SetPadGridY(1);
  gStyle->SetPadGridX(1);
  gStyle->SetTitleXSize(0.06);
  gStyle->SetTitleXOffset(1);
  gStyle->SetTitleYSize(0.07);
  gStyle->SetTitleYOffset(0.9);
  gStyle->SetTitleFont(42,"xyz");
  gStyle->SetStatFont(42);
  gStyle->SetLabelFont(42,"xyz");
  gStyle->SetLabelSize(0.04,"xyz");
  gStyle->SetLabelOffset(0.01,"xyz");
  gStyle->SetNdivisions(505,"xyz");

  int run;
  char path[200];
  if(argc > 2){
    sscanf(argv[1], "%s", path);
    sscanf(argv[2], "%d", &run);
  } else{
    cout << "too few arguments" << endl;
    return -1;
  }
```

**参数说明：**
- `argv[1]`：hist文件路径（如`/besfs5/groups/cal/topup/round18/DataValid/hist/`）
- `argv[2]`：run编号（如85383）

**调用格式：**
```bash
a.out /besfs5/groups/cal/topup/round18/DataValid/hist/ 85383
```

### 4. 变量定义和文件路径设置

```cpp
  char fname[200];
  char fname1[200];
  char fname3[200];
  char rootname[200];
  double xmin = 0;
  double xmax = 60;
  int xbin = 3000;
  bool flag=false;

  int nhit_TQ_total_mdc;
  int nhit_T_total_mdc;
  int nhit_all_emc;
  double etot_all_emc;
  double  ets1;
  double  ets2_pre;
  int  flag_pre;
  int trigChannel_9;

  TCanvas *myC = new TCanvas("fit", "fit", 1000,800);
  myC->Divide(3,2) ;

  sprintf(fname, "%s/hist%05d.root", path, run);
  sprintf(fname1, "run%d", run);
  sprintf(fname3, "shield_run%d.txt", run);
  ofstream fout(fname3);
  sprintf(rootname, "run%d.root", run);

  if( (access(fname,0)) == -1){
      cout<<"can not access the file: "<<fname<<endl;
      return -1;
  }
```

**关键变量：**

| 变量 | 类型 | 含义 |
|------|------|------|
| xmin | double | ΔT最小值（0ms） |
| xmax | double | ΔT最大值（60ms，topup周期） |
| xbin | int | bin数量（3000） |
| nhit_TQ_total_mdc | int | MDC总命中数 |
| etot_all_emc | double | EMC总能量 |
| ets1 | double | 事件时间戳 |
| ets2_pre | double | 前一次注入时间戳 |
| flag_pre | int | 前置事件标记 |
| trigChannel_9 | int | 触发通道9状态 |

**文件路径：**
- `fname`：hist文件路径（如`/besfs5/.../hist85383.root`）
- `fname3`：shield文件输出路径（如`shield_run85383.txt`）
- `rootname`：详细图文件路径（如`run85383.root`）

### 5. 读取interval.txt并判断非topup运行

```cpp
  const char* round_num = getenv("ROUND_NUMBER");
  string interval_path;

  if (round_num != NULL) {
      interval_path = string("/besfs5/groups/cal/topup/round") + round_num + "/DataValid/InjSigTimeCal/interval.txt";
      cout << "INFO: Using ROUND_NUMBER=" << round_num << endl;
  } else {
      interval_path = "/besfs5/groups/cal/topup/round18/DataValid/InjSigTimeCal/interval.txt";
      cout << "WARNING: ROUND_NUMBER not set, using default round18" << endl;
  }

  cout << "INFO: Reading interval file: " << interval_path << endl;

  int read_run;
  int read_TInterval;
  string line;

  ifstream fin(interval_path.c_str());
  if (!fin.is_open()) {
      cout << "ERROR: Cannot open " << interval_path << endl;
      return -1;
  }

  while(getline(fin, line)){
    read_run=0;
    read_TInterval=0;

    istringstream ss(line);
    ss>>read_run>>read_TInterval;
    if(read_run==run ){
      if(read_TInterval==15000000){
        flag=true;
      }
      break;
    }
  }
  fin.close();

  if(flag){
    cout<<"This is a non-topup run"<<endl;
    fout << run << endl;
    fout.close();
    return 0;
  }
```

**功能：**
- 读取interval.txt文件
- 查找当前run的interval值
- 如果interval == 15000000（150ms），标记为非topup运行
- 非topup运行直接跳过寻峰，只输出run号

**interval.txt文件格式：**
```
                    85383
  interval_before_sorting                 15000000
         interval_From_DB                 15000000
   interval_after_sorting                 15000000
```

**非topup运行的判断：**
- interval = 15000000微秒（150ms）→ 非topup运行
- interval = 60（标准topup）→ 需要寻峰
- interval = 20（周期改变）→ 需要寻峰

### 6. 读取hist文件并绑定变量

```cpp
  TFile f(fname);

  TTree* tr = (TTree*)f.Get("event");

  tr->SetBranchAddress("nhit_TQ_total_mdc",&nhit_TQ_total_mdc);
  tr->SetBranchAddress("nhit_T_total_mdc",&nhit_T_total_mdc);
  tr->SetBranchAddress("ets1",&ets1);
  tr->SetBranchAddress("ets2_pre",&ets2_pre);
  tr->SetBranchAddress("flag_pre",&flag_pre);
  tr->SetBranchAddress("trigChannel_9",&trigChannel_9);
  tr->SetBranchAddress("etot_all_emc",&etot_all_emc);
  tr->SetBranchAddress("nhit_all_emc",&nhit_all_emc);
```

**变量绑定：**

| 变量 | 含义 | 单位 |
|------|------|------|
| nhit_TQ_total_mdc | MDC总命中数（Q层） | count |
| nhit_T_total_mdc | MDC总层数 | count |
| ets1 | 事件时间戳 | ns |
| ets2_pre | 前一次注入时间戳 | ns |
| flag_pre | 前置事件标记 | - |
| trigChannel_9 | 触发通道9状态 | - |
| etot_all_emc | EMC总能量 | GeV |
| nhit_all_emc | EMC总hit数 | count |

### 7. 创建三个直方图

```cpp
  TH1F *h[3];
  h[0] = new TH1F("h[0]","",xbin,xmin,xmax);
  h[1] = new TH1F("h[1]","",xbin,xmin,xmax);
  h[2] = new TH1F("h[2]","",xbin,xmin,xmax);
```

**直方图说明：**

| 直方图 | 名称 | X轴 | Y轴（权重） | 用途 |
|--------|------|-----|-----------|------|
| h[0] | MDC响应分布 | ΔT (ms) | nhit_TQ_total_mdc | 寻峰（主要） |
| h[1] | EMC hit数分布 | ΔT (ms) | nhit_all_emc | 辅助分析 |
| h[2] | EMC能量分布 | ΔT (ms) | etot_all_emc | 辅助分析 |

**参数说明：**
- `xbin = 3000`：bin数量
- `xmin = 0`：ΔT最小值（毫秒）
- `xmax = 60`：ΔT最大值（毫秒，对应topup注入周期）

### 8. 填充直方图

```cpp
  int entries = tr->GetEntries();
  int total = 0;
  for(int i=0;i<entries;i++){

    tr->GetEntry(i);
    if(flag_pre!=21 && trigChannel_9==0){

      double x = (ets1-ets2_pre)/2000;  // 计算ΔT（毫秒）
      h[0]->Fill(x,nhit_TQ_total_mdc);  // MDC响应 vs ΔT
      h[1]->Fill(x,nhit_all_emc);       // EMC hit数 vs ΔT
      h[2]->Fill(x,etot_all_emc);       // EMC能量 vs ΔT

      total = total+nhit_TQ_total_mdc;
    }
  }
```

**筛选条件：**
- `flag_pre!=21`：排除随机触发事件
- `trigChannel_9==0`：选择特定触发类型

**ΔT计算：**
```cpp
double x = (ets1-ets2_pre)/2000;  // 单位：毫秒
```
- `ets1`：事件时间戳（纳秒）
- `ets2_pre`：前一次注入时间戳（纳秒）
- 除以2000：将纳秒转换为毫秒

**填充方式：**
- `h[0]->Fill(x, nhit_TQ_total_mdc)`：使用MDC命中数作为权重
- `h[1]->Fill(x, nhit_all_emc)`：使用EMC hit数作为权重
- `h[2]->Fill(x, etot_all_emc)`：使用EMC能量作为权重

### 9. 寻峰算法（核心）

#### 9.1 计算噪声标准

```cpp
  //=========== search peak ===============
  vector<double> peak; peak.clear();
  int noise_standard=total/xbin;

  double bincontent[xbin];
  for (int j=0; j<xbin; j++){
    bincontent[j]=h[0]->GetBinContent(j+1);
  }
```

**噪声标准计算：**
```cpp
int noise_standard=total/xbin;
```
- `total`：所有bin的MDC命中数总和
- `xbin`：bin数量（3000）
- `noise_standard`：平均噪声水平

**说明：**
- 计算整个直方图的平均值作为噪声基线
- 旧版本使用固定值4000，现在使用动态计算的平均值
- 自适应方法能够更好地处理不同数据集

#### 9.2 峰值检测

```cpp
  for (int j=0; j<xbin; j++){
    if (bincontent[j]>noise_standard ||
        (bincontent[j]>bincontent[j-1]*10 && bincontent[j]>4000)){

      int mean=0, interval=50, number=20, threshold=0, sum=0, count=0, count2=0, tmp=0;
      //caculate mean
      for (int k=interval; k<interval+number; k++){
        mean=mean+bincontent[j+k];
      }
      mean=mean/number;
      cout<<"----------------"<<endl;
      cout<<"position="<<xmin+(xmax-xmin)*j/xbin<<endl;
      cout<<"mean="<<mean<<endl;

      //first threshold
      for (int k=interval; k<interval+number; k++){
        threshold=threshold+fabs(bincontent[j+k]-mean);
      }
      threshold=threshold/number;

      //caculate final threshold
      for (int k=interval; k<interval+number; k++){
        if (bincontent[j+k]-mean>threshold){
          sum=sum+bincontent[j+k]-mean;
          count++;
        }
      }
      if (mean==0) threshold=1500;  // 特殊情况：6ms峰
      else threshold=2.7*sum/count;  // 正常情况：2.7倍超出的平均值
      cout<<"threshold="<<threshold<<endl;
      cout<<"mean+threshold=="<<mean+threshold<<endl;
```

**检测条件（满足任一即可）：**

1. **条件1**：`bincontent[j] > noise_standard`
   - bin内容高于噪声标准（平均值）
   - 适用于一般的峰值检测

2. **条件2**：`bincontent[j] > bincontent[j-1]*10 && bincontent[j] > 4000`
   - bin内容高于前一个bin的10倍
   - 且bin内容高于4000
   - 适用于检测陡峭上升的峰值

**峰值参数计算步骤：**

**步骤1：计算背景水平（mean）**
```cpp
int mean=0, interval=50, number=20;
for (int k=interval; k<interval+number; k++){
  mean=mean+bincontent[j+k];
}
mean=mean/number;
```
- 在峰值前50-70个bin处计算平均值
- 这个平均值代表背景水平
- 避免使用峰值本身的数据

**步骤2：计算初步阈值**
```cpp
int threshold=0;
for (int k=interval; k<interval+number; k++){
  threshold=threshold+fabs(bincontent[j+k]-mean);
}
threshold=threshold/number;
```
- 计算峰值附近数据与平均值的平均偏差
- 作为初步阈值

**步骤3：计算最终阈值**
```cpp
int sum=0, count=0;
for (int k=interval; k<interval+number; k++){
  if (bincontent[j+k]-mean>threshold){
    sum=sum+bincontent[j+k]-mean;
    count++;
  }
}
if (mean==0) threshold=1500;  // 特殊情况：6ms峰
else threshold=2.7*sum/count;  // 正常情况：2.7倍超出的平均值
```

**阈值计算公式：**
```
threshold = 2.7 × (超出mean的部分的平均值)
```

**特殊情况处理：**
- 如果`mean==0`（6ms附近），使用固定阈值1500
- 否则，使用2.7倍的超出平均值

**物理意义：**
- 统计显著超出平均值的bin
- 乘以2.7作为显著性阈值（类似3σ标准）
- 动态阈值能够适应不同数据集的噪声水平

#### 9.3 扩展峰值边界

**向右扩展：**
```cpp
      //broaden peak
      int flag1=j,flag2=j;
      for (int k=j; k<xbin-1; k++){//right
        if ((bincontent[flag1]+bincontent[flag1+1])/2-mean>threshold ||
            bincontent[flag1+1]/bincontent[flag1+2]>10) flag1=flag1+1;
        else break;
      }

      if (fabs(xmin+(xmax-xmin)*j/xbin-6)>1){//not 6ms
        tmp=flag1;
        for (int k=1; k<21; k++){
          if (bincontent[flag1+k]-mean>threshold){
            tmp=flag1+k;
            count2++;
          }
        }
        if (count2>3) flag1=tmp;  // 如果有超过3个连续高bin，扩展
      }
```

**扩展条件（满足任一即可）：**

1. **条件1**：`(bincontent[flag1]+bincontent[flag1+1])/2 - mean > threshold`
   - 相邻两个bin的平均值 - mean > threshold
   - 峰值仍然显著高于背景

2. **条件2**：`bincontent[flag1+1]/bincontent[flag1+2] > 10`
   - 下一个bin/下下个bin > 10
   - 陡峭下降（可能是峰值边缘）

**特殊处理：处理远离6ms的小峰**
```cpp
if (fabs(xmin+(xmax-xmin)*j/xbin-6)>1){
  tmp=flag1;
  count2=0;
  for (int k=1; k<21; k++){
    if (bincontent[flag1+k]-mean>threshold){
      tmp=flag1+k;
      count2++;
    }
  }
  if (count2>3) flag1=tmp;  // 如果有超过3个连续高bin，扩展
}
```
- 检查峰值是否远离6ms
- 检查后续20个bin是否有连续高值
- 如果有超过3个连续高bin，扩展峰值边界

**向左扩展：**
```cpp
      for (int k=0; k<2; k++){//left
        if (bincontent[flag2-1]-bincontent[flag2-2]>threshold) flag2=flag2-1;
      }
```

**扩展条件：**
- `bincontent[flag2-1] - bincontent[flag2-2] > threshold`
- 向左最多扩展2个bin

#### 9.4 噪声检测

```cpp
      if (fabs(xmin+(xmax-xmin)*flag2/xbin-22)<3 ||
          fabs(xmin+(xmax-xmin)*flag2/xbin-42)<3) {
        cout<<"threshold2_ratio="<<((bincontent[flag1-1]+bincontent[flag1])/2-mean)/(sum/count)<<endl;
      }
```

**噪声检测：**
- 检查峰值是否在22ms或42ms附近
- 这些位置可能是50Hz电源噪声（周期20ms）
- 输出阈值比率用于调试

**物理意义：**
- 50Hz电源周期 = 20ms
- 22ms = 1.1 × 20ms
- 42ms = 2.1 × 20ms
- 这些位置的峰值可能是电源噪声干扰

#### 9.5 异常峰值过滤

```cpp
      bool NG=false;
      if (fabs(xmin+(xmax-xmin)*flag2/xbin-1.5)>1.6 && (flag1+1-flag2)<=3) {
        NG=true;  // 峰值太窄（<3个bin），可能是噪声
      }

      if (!NG){
        peak.push_back(xmin+(xmax-xmin)*flag2/xbin);      // 峰值起始时间
        peak.push_back(xmin+(xmax-xmin)*(flag1+1)/xbin); // 峰值结束时间
      }

      j=flag1;  // 跳过已处理的bin
```

**过滤条件：**
- 峰值起始不在1.5ms附近（±1.6ms）
- 且峰值宽度 <= 3个bin（<0.6ms）

**过滤逻辑：**
- 如果满足过滤条件，标记为NG（噪声）
- NG的峰值不加入peak列表
- j跳到flag1，避免重复处理

**物理意义：**
- 1.5ms附近的小峰可能是真实的信号峰
- 其他位置的窄峰（<0.6ms）可能是噪声
- 过滤窄峰可以提高信噪比

### 10. 输出结果

```cpp
  fout<<run;
  for (unsigned int i=0; i<peak.size(); i++){
    fout<<setw(5)<<""<<setiosflags(ios::fixed)<<setprecision(2)<<peak[i];
  }
  fout<<endl;

  TCanvas* c2 = new TCanvas ("c2","detail", 300, 200, 1300, 700);
  h[0]->Draw();  // 绘制MDC响应分布
  c2->SaveAs(rootname);  // 保存为run{runNo}.root

  f.Close();
  fout.close();
  return 0;
}
```

**输出格式：**
```cpp
fout<<run;
for (unsigned int i=0; i<peak.size(); i++){
  fout<<setw(5)<<""<<setiosflags(ios::fixed)<<setprecision(2)<<peak[i];
}
fout<<endl;
```

**示例输出：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
```

**字段说明：**
- 第1列：run编号
- 第2列以后：峰值起始和结束时间（成对出现，单位：毫秒）
- `setw(5)`：每个字段宽度5个字符
- `setprecision(2)`：保留2位小数

**详细图保存：**
```cpp
TCanvas* c2 = new TCanvas ("c2","detail", 300, 200, 1300, 700);
h[0]->Draw();  // 绘制MDC响应分布
c2->SaveAs(rootname);  // 保存为run{runNo}.root
```
- 保存MDC响应分布直方图
- 文件名：run{runNo}.root
- 用于人工审核和调试

---

## 六、add.sh脚本详解

### 脚本功能

`add.sh` 脚本负责将所有run的shield_run*.txt文件合并到window.dat文件。

### 脚本内容

```bash
cat shield_run* >> window.dat
```

### 脚本说明

**功能：**
- 读取所有shield_run*.txt文件
- 将内容追加到window.dat文件
- 生成最终的滤波窗口参数文件

**文件操作：**
- `cat`：连接文件并输出
- `>>`：追加到文件（不覆盖原有内容）
- `window.dat`：最终输出文件

**window.dat文件格式：**
```
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
...
```

**预期内容：**
- 所有run的滤波窗口参数
- 每行对应一个run
- 每个run可能有1个主窗口和多个噪声窗口

---

## 七、步骤3的子步骤详解

### 步骤3.1：第三次作业提交并检查shield文件（合并版）

**功能：**
- 进入search_peak目录
- 执行genJob.sh脚本（如果submit_job=True）
- 检查shield文件是否完整
- 定时检查所有run完成

**关键特性：**

1. **submit_job参数：**
   - 如果`submit_job=True`（默认）：先提交作业，然后检查shield文件
   - 如果`submit_job=False`：跳过作业提交，直接检查shield文件

2. **阶段1：提交作业（仅当submit_job=True）：**
   - 执行`cd {SEARCH_PEAK_DIR} && source {ENV_SCRIPT} && ./genJob.sh`
   - 检查生成的作业文件（run_*_3.txt）
   - 输出作业文件列表

3. **阶段2：检查shield文件：**
   - 获取作业文件列表，提取run号
   - 定期检查shield_run{runNo}.txt文件
   - 默认等待25分钟，每30秒检查一次
   - 支持通过参数自定义等待时间

4. **定时检查：**
   - 每次检查所有未完成的run号
   - 显示检查进度
   - 记录已完成和未完成的run号

5. **返回结果：**
   - 如果所有shield文件都生成，返回成功
   - 如果超时，返回未完成的run号列表

**示例运行：**

```bash
# 方法1：提交作业并检查（默认）
python run.py --step 3.1

# 方法2：只检查，不提交作业
python run.py --step 3.1 --submit-job false

# 方法3：自定义等待时间
python run.py --step 3.1 --max-wait 30
```

### 步骤3.2：运行add.sh脚本

**功能：**
- 进入search_peak目录
- 执行add.sh脚本
- 合并所有shield_run*.txt文件
- 生成window.dat文件

**执行命令：**
```bash
cd {SEARCH_PEAK_DIR} && ./add.sh
```

**输出：**
- window.dat文件（包含所有run的滤波窗口参数）

**示例运行：**

```bash
python run.py --step 3.2
```

---

## 八、window.dat文件格式详解

### 文件结构

**格式：**
```
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
runNo  peak1_start  peak1_end  peak2_start  peak2_end  ...
...
```

**示例：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
65261  0.45  4.15  21.75  22.35  41.45  42.25
```

### 字段说明

| 字段 | 含义 | 单位 | 示例 |
|------|------|------|------|
| runNo | run编号 | - | 65260 |
| peak1_start | 第1个峰值起始时间 | 毫秒 | 0.50 |
| peak1_end | 第1个峰值结束时间 | 毫秒 | 4.20 |
| peak2_start | 第2个峰值起始时间 | 毫秒 | 21.80 |
| peak2_end | 第2个峰值结束时间 | 毫秒 | 22.40 |
| ... | 更多峰值 | 毫秒 | ... |

### 预期窗口数量

**标准情况（1主窗口 + 3噪声窗口）：**

```
65260  0.50  4.20  21.80  22.40  41.50  42.30
       ↑主窗口   ↑22ms附近噪声  ↑42ms附近噪声
```

**窗口说明：**

| 窗口 | 起始时间 | 结束时间 | 宽度 | 来源 |
|------|---------|---------|------|------|
| 主窗口 | 0.50ms | 4.20ms | 3.70ms | 注入期间的主要背景污染 |
| 噪声窗口1 | 21.80ms | 22.40ms | 0.60ms | 50Hz电源噪声（1.1×周期） |
| 噪声窗口2 | 41.50ms | 42.30ms | 0.80ms | 50Hz电源噪声（2.1×周期） |
| 噪声窗口3 | 未知 | 未知 | 未知 | 其他干扰源 |

### 可能的噪声源

| 频率 | 周期 | 预期位置 | 说明 |
|------|------|---------|------|
| 2Hz | 500ms | 0ms, 500ms | 低频干扰 |
| 20Hz | 50ms | 0ms, 50ms | 中频干扰 |
| 40Hz | 25ms | 0ms, 25ms, 50ms | 中频干扰 |
| 50Hz | 20ms | 0ms, 20ms, 40ms | 电源噪声 |

### 与论文的对应

window.dat文件对应论文中图5的 **"确定滤波窗口参数"** 部分，是离线事件滤波器校准的关键输出。

---

## 九、第三次提交作业在离线事件滤波器中的作用

### 数据流程图

```
第二次提交作业生成的hist文件
    ↓
[步骤3.1：第三次作业提交]
    ├─ 提交寻峰作业
    │  ├─ 读取hist文件
    │  ├─ 读取interval.txt
    │  ├─ 创建MDC响应直方图
    │  ├─ 执行寻峰算法
    │  └─ 生成shield_run{runNo}.txt
    └─ 检查shield文件
       ├─ 获取run号列表
       ├─ 定期检查文件生成
       └─ 返回完成状态
    ↓
shield_run*.txt文件（每个run的滤波窗口）
    ↓
[步骤3.2：运行add.sh脚本]
    ├─ 合并所有shield文件
    └─ 生成window.dat
    ↓
window.dat文件（所有run的滤波窗口参数）
    ↓
[步骤4：第四次作业]
    ├─ 应用窗口参数
    ├─ 生成检查图片
    └─ 验证滤波效果
    ↓
[步骤5-6：滤波器优化]
    ├─ 调整窗口参数
    ├─ 迭代优化
    └─ 最终确定滤波窗口
    ↓
[步骤7：提交数据库]
    └─ 将滤波器参数保存到数据库
    ↓
在事件重建时应用滤波器
```

### 物理意义

通过识别MDC响应中的背景峰值，步骤3.1-3.2为离线事件滤波器提供了：
- 需要过滤的时间窗口（主窗口）
- 噪声源的标记（噪声窗口）
- 滤波器参数的初步估计

这是实现离线事件滤波器的核心算法，直接决定了滤波器的性能。

### 与论文的对应

步骤3.1-3.2对应论文中图4的 **"MDC和EMC响应 vs ΔT分布"** 分析部分，以及图5的 **"确定滤波窗口参数"** 部分。

---

## 十、示例：run65260的完整流程

### 1. hist文件

```bash
/besfs5/groups/cal/topup/round18/DataValid/hist/hist65260.root
```

**内容：**
- TTree对象：event
- 关键变量：nhit_TQ_total_mdc, ets1, ets2_pre, flag_pre, trigChannel_9, etot_all_emc, nhit_all_emc

### 2. 作业配置文件（run_65260_3.txt）

```bash
/besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/search_peak/a.out /besfs5/groups/cal/topup/round18/DataValid/hist/ 65260
```

**说明：**
- 执行路径：search_peak/a.out
- hist文件路径：/besfs5/.../hist/
- run编号：65260

### 3. 输出文件

**shield_run65260.txt：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
```

**说明：**
- run编号：65260
- 主窗口：0.50ms - 4.20ms（宽度3.70ms）
- 噪声窗口1：21.80ms - 22.40ms（宽度0.60ms，22ms附近）
- 噪声窗口2：41.50ms - 42.30ms（宽度0.80ms，42ms附近）

**run65260.root：**
- 详细图文件
- 包含MDC响应分布直方图
- 用于人工审核

### 4. window.dat文件

**内容：**
```
65260  0.50  4.20  21.80  22.40  41.50  42.30
65261  0.45  4.15  21.75  22.35  41.45  42.25
...
```

**说明：**
- 所有run的滤波窗口参数
- 每行对应一个run
- 每个run有1个主窗口和多个噪声窗口

---

## 十一、常见问题和解决方法

### 问题1：作业提交失败

**症状：**
```
执行genJob.sh脚本失败
```

**原因：**
- hist文件不存在
- 环境变量未设置
- 权限不足

**解决方法：**
- 检查hist文件是否存在：`ls /besfs5/.../hist/hist*.root`
- 检查环境变量：`echo $ROUND_NUMBER`
- 检查权限：`ls -la genJob.sh`

### 问题2：shield文件检查超时

**症状：**
```
在 25 分钟内未完成所有shield文件的生成
```

**原因：**
- 计算集群负载高
- run数量多
- 网络问题

**解决方法：**
- 增加等待时间：`python run.py --step 3.1 --max-wait 30`
- 检查作业状态：`hep_q -u topup`
- 重新提交失败的作业

### 问题3：非topup运行检测

**症状：**
```
This is a non-topup run
```

**原因：**
- interval.txt中的interval值为15000000（150ms）
- 该run处于非topup模式

**解决方法：**
- 这是正常情况，非topup运行会自动跳过寻峰
- 检查interval.txt确认interval值
- 如果需要处理非topup运行，修改Search_peak.cpp中的判断逻辑

### 问题4：窗口数量异常

**症状：**
```
window.dat中的窗口数量不符合预期（1主窗口 + 3噪声窗口）
```

**原因：**
- 噪声水平过高
- 寻峰算法参数不合适
- 数据质量问题

**解决方法：**
- 检查详细的run{runNo}.root图文件
- 调整寻峰算法参数（threshold、mean等）
- 手动审核数据质量

### 问题5：window.dat文件为空

**症状：**
```
window.dat文件没有内容或只有少量run
```

**原因：**
- 所有run都是非topup运行
- shield文件未正确生成
- add.sh脚本执行失败

**解决方法：**
- 检查interval.txt确认run的注入模式
- 检查shield_run*.txt文件是否存在
- 手动执行add.sh脚本：`cd search_peak && ./add.sh`

---

## 十二、总结

### 第三次提交作业的本质

第三次提交作业是 **BESIII离线事件滤波器校准流程的关键转折点**，其核心任务是：

1. **分析MDC响应分布**：从hist文件中提取MDC响应与ΔT的关系
2. **识别背景峰值**：使用自适应阈值算法识别显著的峰值
3. **计算滤波窗口**：确定每个峰值的起始和结束时间
4. **生成window.dat文件**：保存所有run的滤波窗口参数

### 关键技术点

1. **genJob.sh脚本**：自动化作业生成和提交
2. **Search_peak.cpp**：核心寻峰算法
3. **自适应阈值算法**：动态计算噪声水平和阈值
4. **峰值边界扩展**：准确确定峰值的起始和结束
5. **异常峰值过滤**：去除窄峰（噪声）
6. **定时检查机制**：确保作业完成
7. **add.sh脚本**：合并所有run的结果

### 物理意义

通过识别MDC响应中的背景峰值，步骤3.1-3.2为：
- 识别注入背景污染事件
- 确定最优滤波窗口
- 提高数据质量
- 保证物理结果的可靠性

提供了关键的滤波窗口参数。

### 算法参数总结

| 参数 | 值 | 物理意义 |
|------|---|---------|
| xbin | 3000 | ΔT分布的bin数量 |
| xmin | 0 | ΔT最小值（毫秒） |
| xmax | 60 | ΔT最大值（毫秒，topup周期） |
| interval | 50 | 计算背景平均值的起始位置 |
| number | 20 | 计算背景平均值的bin数量 |
| 阈值系数 | 2.7 | 峰值检测的阈值乘数 |
| 最小峰值宽度 | 3 bins (<0.6ms) | 过滤窄峰（噪声） |
| 非topup间隔 | 15000000 | 15ms注入间隔 |

### 未来改进方向

1. **优化寻峰算法：**
   - 尝试不同的阈值计算方法
   - 改进峰值边界扩展逻辑
   - 提高噪声抑制能力

2. **支持多种注入模式：**
   - 自动识别不同的注入模式
   - 动态调整算法参数
   - 支持混合模式数据处理

3. **增强异常检测：**
   - 添加更多数据质量检查
   - 实现更智能的异常识别
   - 提供更详细的错误诊断

4. **改进可视化：**
   - 生成更详细的检查图片
   - 添加峰值标记和注释
   - 支持交互式审核

---

## 附录A：相关文件路径

### 远程服务器路径

```
/besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/search_peak/  # 工作目录
/besfs5/groups/cal/topup/round18/DataValid/hist/                             # hist文件目录
/besfs5/groups/cal/topup/round18/DataValid/InjSigTimeCal/                     # interval.txt目录
```

### 本地路径

```
C:\Users\孟皇薪\Desktop\topup\downloads\                    # 下载目录
C:\Users\孟皇薪\Desktop\topup\logs\                         # 日志目录
C:\Users\孟皇薪\Desktop\topup\.step_progress                # 进度文件
```

---

## 附录B：命令参考

### 执行步骤

```bash
# 执行单个步骤（提交作业并检查）
python run.py --step 3.1

# 执行单个步骤（只检查，不提交作业）
python run.py --step 3.1 --submit-job false

# 执行单个步骤（自定义等待时间）
python run.py --step 3.1 --max-wait 30

# 执行步骤3.2
python run.py --step 3.2

# 执行所有步骤
python run.py --all

# 从断点继续
python run.py --continue
```

### 查看作业状态

```bash
# 查看topup用户的作业
hep_q -u topup -g offlinerun

# 查看具体作业详情
hep_q -j <job_id>
```

### 手动操作

```bash
# 进入search_peak目录
cd /besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/search_peak

# 提交作业
./genJob.sh

# 查看作业文件
ls run_*_3.txt

# 查看shield文件
ls shield_run*.txt

# 合并shield文件
./add.sh

# 查看window.dat
cat window.dat

# 查看详细图
ls run*.root
```

---

## 附录C：术语表

| 术语 | 英文 | 含义 |
|------|------|------|
| IST | Injection Signal Time Stamp | 注入信号时间戳 |
| ETS | Event Time Stamp | 事件时间戳 |
| ΔT | Delta Time | 事件与注入的时间差 |
| MDC | Main Drift Chamber | 主漂移室 |
| EMC | Electromagnetic Calorimeter | 电磁量能器 |
| topup | top-up injection | 顶部注入 |
| ROOT | ROOT Data Analysis Framework | ROOT数据分析框架 |
| shield | shield window | 滤波窗口 |
| peak | peak | 峰值 |
| threshold | threshold | 阈值 |
| noise standard | noise standard | 噪声标准 |
| mean | mean | 背景水平（平均值） |

---

**文档创建时间：** 2026年2月20日  
**最后更新时间：** 2026年2月20日  
**基于论文：** "Suppression of top-up injection backgrounds with offline event filter in the BESIII experiment" (Radiation Detection Technology and Methods, 2022)  
**基于代码：** genJob.sh, Search_peak.cpp, add.sh  
**作者：** iFlow CLI