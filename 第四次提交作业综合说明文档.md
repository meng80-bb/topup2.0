# 第四次提交作业综合说明文档

## 文档说明

本文档详细说明了BESIII离线事件滤波器校准流程中**第四次提交作业**（步骤4.1-4.2）的目的、意义、技术实现和物理背景。

**目标读者：** 新用户、需要了解项目背景的开发者、iFlow CLI参考文档

**相关文件：**
- 步骤4.1：`step4_fourth_job_submission.py` - 第四次作业提交并检查文件
- 步骤4.2：`step4_2_check_files.py` - 合并图片
- 远程脚本：`genJob.sh` - 作业提交脚本
- 核心程序：`checkCalibConst.cpp` - 滤波器验证程序
- 操作手册：`A-topup操作.docx`
- 论文：`OfflineEventFilter_rdtm2022.pdf`

---

## 一、第四次提交作业概述

### 什么是第四次提交作业？

第四次提交作业是BESIII离线事件滤波器校准流程中的**验证与优化阶段**，其核心任务是将步骤3.2生成的滤波窗口参数（window.dat）应用到实际数据中，通过可视化检查验证滤波效果，并统计滤波器的性能指标。

### 在整个流程中的位置

第四次提交作业对应论文图5所示的离线数据处理流程中的 **"滤波器验证与优化"** 环节，是从"滤波器参数确定"到"滤波器应用"的关键步骤。

```
步骤3.2：生成window.dat
    ↓
[步骤4.1：第四次作业提交]
    ↓
读取window.dat，应用滤波窗口
    ↓
生成检查图片（cut_detail, after, before, check）
    ↓
统计过滤比率
    ↓
[步骤4.2：合并图片]
    ↓
生成合并PDF文件
    ↓
人工检查滤波效果
    ↓
迭代优化窗口参数（如需要）
```

### 步骤4的子步骤关系

步骤4包含2个子步骤，形成一个完整的滤波器验证流程：

```
步骤4.1：第四次作业提交（核心）
    ├─ 删除旧文件（PDF和run开头的文件）
    ├─ 提交作业（可选submit_job参数）
    ├─ 检查生成的文件（可选check参数）
    └─ 定时检查所有run完成
    ↓
步骤4.2：合并图片
    ├─ 进入checkShieldCalib目录
    ├─ 在SL6容器中合并PNG图片为PDF
    └─ 下载PDF到本地
```

**说明：**
- **步骤4.1**是核心，负责提交作业并生成检查文件
- **步骤4.2**负责合并所有run的检查图片，便于批量查看
- 两个步骤共同完成从滤波窗口参数到滤波效果验证的转换

### 与前三次提交作业的区别

| 对比项 | 第一次提交作业 | 第二次提交作业 | 第三次提交作业 | 第四次提交作业 |
|-------|--------------|--------------|--------------|--------------|
| **输入数据** | 原始数据（*.raw文件） | 第一次提交的ROOT文件 | 第二次提交的hist文件 | 第三次提交的window.dat |
| **输出文件** | InjSigTime文件、Interval文件 | hist*.root、check*.png | shield_run*.txt、window.dat | run{runNo}_*.png、run{runNo}_output.txt、mergedd_CheckShieldCalib.pdf |
| **核心算法** | GetRawETS、GetTIntervalAlg | ResetEtsAlg、OfflineEvtFilterCalibAlg | Search_peak.cpp（寻峰算法） | checkCalibConst.cpp（滤波器验证） |
| **物理意义** | 提取时间戳（IST和ETS）、计算ΔT | 分析探测器响应与ΔT的关系 | 识别背景峰值，确定滤波窗口 | 应用滤波窗口，验证滤波效果 |
| **后续用途** | 计算ΔT = ETS - IST | 识别背景峰值 | 应用滤波窗口到事件 | 滤波器优化、ETS_cut确定 |
| **关键输出** | interval.txt（注入间隔） | histogram文件 | window.dat（滤波窗口参数） | 检查图片、统计信息 |
| **非topup处理** | 识别IST=15000000 | 正常处理 | 正常处理 | 直接返回，不生成图片 |

---

## 二、第四次提交作业的物理背景

### 研究背景：BEPCII顶部注入（Top-up Injection）

**BEPCII于2019年底实现了顶部注入（top-up injection）：**
- 时间平均积分亮度提高了约30%
- 但频繁的束流注入在数据采集期间造成了明显的注入背景
- 这些背景严重影响了数据质量和物理结果的可靠性

### 核心问题：注入背景污染

**注入背景特征：**

1. **MDC（主漂移室）响应：**
   - 暗电流在注入期间增加约2倍
   - MDC几乎完全被占满，导致径迹重建困难
   - 对束流相关背景最敏感（最靠近束流管）
   - 论文图4a显示：在ΔT很小（0-10ms）时，MDC占用率可达60%以上（4000+ hits）

2. **EMC（电磁量能器）响应：**
   - 总能量沉积可达1000 GeV以上
   - 远高于质心对撞能量（约2.0 GeV）
   - 对束流相关背景也很敏感
   - 论文图4b显示：在ΔT很小时，EMC能量沉积可达200 GeV以上

**峰值出现的物理原因：**
- **注入瞬间**：束流注入时产生大量次级粒子
- **瞬时背景**：这些次级粒子在探测器中产生大量信号
- **时间集中**：背景主要发生在注入后的短时间内（0-10ms）
- **能量沉积**：导致MDC和EMC响应急剧增加

### 解决方案：离线事件滤波器（Offline Event Filter）

**离线事件滤波器的作用：**
1. **背景峰值识别：** 基于MDC和EMC的响应识别严重背景污染时期
2. **时间差计算：** 计算 ΔT = ETS - IST（事件相对于注入的时间）
3. **滤波窗口确定：** 使用MDC和EMC的平均占用率和总能量沉积分布确定滤波窗口
4. **事件过滤：** 在事件重建前，离线事件滤波器算法访问数据库，决定保留或跳过每个事件

**应用效果：**
- 有效去除被注入背景污染的数据
- 显著改善数据质量
- 保持最佳数据采集效率
- 有助于避免蒙特卡罗模拟与数据之间的不一致性

**论文中的验证结果：**
- 论文图7：展示应用滤波窗口前后的数据分布对比
- 论文表1：统计了不同滤波窗口下的数据保留率和背景去除效果

---

## 三、第四次提交作业的核心目标

### 1. 验证滤波窗口的有效性

**目标：** 确认步骤3.2生成的滤波窗口参数能有效过滤注入背景

**验证方法：**
- 将滤波窗口应用到实际数据
- 对比滤波前后的数据分布
- 检查是否还有未过滤的背景峰值

**成功标准：**
- after_cut图中无明显黑色竖线（未过滤的背景）
- cut_detail图中所有峰值完全在红线之间
- 过滤比率在合理范围内（<5%）

### 2. 评估滤波器性能

**目标：** 量化评估滤波器的性能指标

**统计指标：**
- `remove_ratio`：过滤掉的事件占总事件数的比例
- `remove_num`：过滤掉的事件数
- `TotalEvent`：总事件数
- `num_5k_total`：MDC命中数>5000的事件数
- `num_5k_Incut`：滤波窗口内MDC命中数>5000的事件数
- `num_5k_Outcut`：滤波窗口外MDC命中数>5000的事件数

**性能标准：**
- `remove_ratio < 5%`：不过度过滤
- `num_5k_Incut/num_5k_total > 80%`：有效过滤背景

### 3. 支持非topup模式

**目标：** 正确处理非topup数据（IST=15000000）

**处理方式：**
- 在执行滤波前，先检查interval.txt中的IST值
- 如果IST=15000000，识别为非topup模式
- 直接返回，不生成检查图片
- 不产生滤波窗口应用的结果

**原因：**
- 非topup模式下没有注入信号
- 不需要应用滤波窗口
- 直接跳过处理，避免无效计算

### 4. 提供可视化检查工具

**目标：** 生成便于人工检查的图片文件

**生成的图片类型：**

1. **cut_detail图（滤波窗口详细图）**
   - 内容：14个子图（2行×7列），每个子图显示一个滤波窗口
   - Y轴：hit_TQ_MDC（MDC响应，对数刻度）
   - X轴：ETS-IST(ms)（事件相对于注入的时间）
   - 红色竖线：滤波窗口的边界（cut_down和cut_up）
   - 用途：检查每个滤波窗口的设置是否合理

2. **after_cut图（应用滤波窗口后的结果图）**
   - 内容：6个子图（2行×3列）
   - 上排：时间尺度~500ns
   - 下排：时间尺度~秒级
   - 用途：验证滤波窗口后的数据质量

3. **before_cut图（应用滤波窗口前的结果图）**
   - 内容：与after_cut相同
   - 用途：对比滤波前后的数据分布

4. **check图（整体检查图）**
   - 内容：6个子图
   - 用途：检查非topup事件的分布

---

## 四、步骤4.1：第四次作业提交并检查文件

### 功能描述

步骤4.1负责提交滤波器验证作业，检查生成的检查文件。

### 执行命令

**步骤4.1执行的命令：**

```bash
# 1. 进入checkShieldCalib目录
cd /besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/checkShieldCalib

# 2. 删除旧文件
rm -f *.pdf && rm -f run*

# 3. 激活环境并提交作业
source ~/w720
./genJob.sh
```

**genJob.sh脚本内容：**

```bash
#!/bin/bash

pwdir=`pwd`
ntuplePath=/besfs5/groups/cal/topup/round${ROUND_NUMBER}/DataValid/hist
str="root"
nfile=0

for file in `/bin/ls ${ntuplePath}/hist*.root`;
do
    length=`expr ${#file} - 10`
    runNo=${file:$length:5}

    line="${pwdir}/a.out ${ntuplePath} ${runNo} "

    job=run_${runNo}_4.txt

    echo "$line" > "${job}"
    chmod +x ${job}
    hep_sub -g offlinerun ${job}
    nfile=`expr $nfile + 1`

done

echo "Total = $nfile files"
echo "DONE"
```

**作业文件示例（run_85383_4.txt）：**

```
/besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/checkShieldCalib/a.out /besfs5/groups/cal/topup/round18/DataValid/hist 85383
```

### 参数说明

**步骤4.1支持以下参数：**

| 参数 | 类型 | 默认值 | 说明 |
|-----|------|--------|------|
| `date` | 字符串 | 必需 | 日期参数（如250519） |
| `submit_job` | 布尔 | True | 是否提交作业 |
| `check` | 布尔 | False | 是否检查生成的文件（非topup模式下不检查） |
| `max_wait_minutes` | 整数 | 25 | 文件检查的最大等待时间（分钟） |

**非topup模式说明：**
- 在非topup模式下，IST=15000000，不会生成检查图片
- 因此`check`参数默认为False
- 如果强制设为True，检查将失败（没有PNG文件）

### 检查的文件

**当check=True时，检查以下4个文件：**

1. `run{runNo}_cut_detail.png` - 滤波窗口详细图
2. `run{runNo}_after_cut.png` - 应用滤波后的结果图
3. `run{runNo}_before_cut.png` - 应用滤波前的对比图
4. `run{runNo}_check.png` - 整体检查图

**定时检查逻辑：**
- 默认等待25分钟（可配置）
- 每30秒检查一次
- 如果超时，返回未完成的run号列表

---

## 五、checkCalibConst.cpp核心算法分析

### 1. 程序入口和参数

**调用格式：**

```cpp
int main(int argc, char* argv[]){
    int run;
    char path[200];
    if(argc > 2){
        sscanf(argv[1], "%s", path);  // hist目录路径
        sscanf(argv[2], "%d", &run);  // run号
    } else{
        cout << "too few arguments" << endl;
        return -1;
    }
    // ... 后续处理
}
```

### 2. 非topup模式检测

**检测逻辑：**

```cpp
// 读取interval.txt，查找当前run的IST值
const char* round_num = getenv("ROUND_NUMBER");
string base_path;
if (round_num != NULL) {
    base_path = string("/besfs5/groups/cal/topup/round") + round_num;
} else {
    base_path = "/besfs5/groups/cal/topup/round18";
}

string interval_path = base_path + "/DataValid/InjSigTimeCal/interval.txt";
ifstream fin(interval_path.c_str());

while(getline(fin, line)){
    read_run=0;
    read_TInterval=0;
    istringstream ss(line);
    ss>>read_run>>read_TInterval;
    if(read_run==run){
        if(read_TInterval==15000000){
            flag_interval=true;  // 检测到非topup模式
        }
        break;
    }
}

if(flag_interval){
    cout<<"This is a non-topup run"<<endl;
    return 0;  // 直接返回，不生成图片
}
```

### 3. 读取滤波窗口参数

**读取window.dat：**

```cpp
string window_path = base_path + "/DataValid/Determining_50Hz_cut/search_peak/window.dat";
ifstream fin1(window_path.c_str());

while(getline(fin1, line1)){
    double i = 0;
    int j = 0;
    istringstream ss1(line1);
    while(ss1>>i){
        read_info[j]=i;
        j++;
    }

    if(run==read_info[0]){
        num = (j-1)/2;  // 窗口数量
        for(int k=0;k<num;k++){
            cut_down[k]=read_info[2*k+1];  // 窗口起始
            cut_up[k]=read_info[2*k+2];    // 窗口结束
        }
        flag_read = 1;
    }
    if(flag_read) break;
}
```

**窗口格式示例：**

```
65260  0.00  0.02  0.06  0.08  0.10  0.12  0.14  0.18  0.20  0.22  0.26  0.28  0.46  0.48  0.66  0.68
       ↑run号  ↑主窗口  ↑噪声窗口1  ↑噪声窗口2  ...
```

### 4. 构建滤波条件

**滤波条件生成：**

```cpp
int InjSigInterval = 60;  // topup周期：60ms
char basic_cut[200];
sprintf(basic_cut, "flag_pre!=21 && trigChannel_9==0 && (ets1-ets2_pre)/2000>0 && (ets1-ets2_pre)/2000<%d", InjSigInterval);

char connect[20] = " && ";
char *remove_cut = basic_cut;

// 为每个窗口添加过滤条件
for(int i=0;i<NumOfCut;i++){
    sprintf(cut[i],"!((ets1-ets2_pre)/2000>%f&&(ets1-ets2_pre)/2000<%f)",cut_down[i],cut_up[i]);
    remove_cut = Form("%s%s%s", remove_cut,connect,cut[i]);
}

cout<<remove_cut<<endl;
```

**最终滤波条件示例：**

```cpp
flag_pre!=21 && trigChannel_9==0 && (ets1-ets2_pre)/2000>0 && (ets1-ets2_pre)/2000<60 &&
!((ets1-ets2_pre)/2000>0.000000&&(ets1-ets2_pre)/2000<0.020000) &&
!((ets1-ets2_pre)/2000>0.060000&&(ets1-ets2_pre)/2000<0.080000) &&
...
```

### 5. 生成cut_detail图

**cut_detail图生成逻辑：**

```cpp
TCanvas* c = new TCanvas ("c","c",1500,1200);
int length = ceil((double)NumOfCut/2);
c->Divide(length,2);  // 2行×7列布局

for(int i=0;i<NumOfCut;i++){
    sprintf(hist,"h%d",i);
    h[i] = new TH1F(hist,"",xbin,xmin[i],xmax[i]);

    // 填充直方图
    for(int j=0;j<entries;j++){
        tr->GetEntry(j);
        double y = (ets1-ets2_pre)/2000;
        if(flag_pre!=21 && trigChannel_9==0){
            h[i]->Fill(y,nhit_TQ_total_mdc);
        }
    }

    // 画图
    c->cd(i+1);
    gPad->SetLogy();
    h[i]->Draw();
    h[i]->SetTitle(fname1);
    h[i]->GetXaxis()->SetTitle("ETS-IST(ms)");
    h[i]->GetYaxis()->SetTitle("hit_TQ_MDC");

    // 画窗口边界线
    line_down[i] = new TLine(cut_down[i],height2,cut_down[i],height1);
    line_up[i] = new TLine(cut_up[i],height2,cut_up[i],height1);
    line_down[i]->Draw("Same");
    line_up[i]->Draw("Same");
    line_down[i]->SetLineColor(2);  // 红色
    line_up[i]->SetLineColor(2);
}

c->SaveAs(pdfname);  // 保存为PNG文件
```

### 6. 生成after_cut和before_cut图

**after_cut图生成逻辑：**

```cpp
TCanvas* c1 = new TCanvas ("c1","c1",1500,1200);
c1->Divide(3,2);

// 应用滤波条件后的数据
for(int i=0;i<entries;i++){
    tr->GetEntry(i);
    bool goodEvtFlag1 = true;
    double x = (ets1-ets2_pre)/2000;

    // 检查是否在滤波窗口内
    for(int j=0;j<NumOfCut;j++){
        if((x >= cut_down[j] && x < cut_up[j])){
            goodEvtFlag1 = false;
            break;
        }
    }

    if(goodEvtFlag1 && TopupEvtFlag){
        th1->Fill(x,nhit_TQ_total_mdc);  // MDC hits vs ΔT
        th2->Fill(x,nhit_all_emc);        // EMC hits vs ΔT
        th3->Fill(x,etot_all_emc/1000);   // EMC energy vs ΔT
    }
}

c1->Print(pdfname1);  // 保存after_cut图
```

**before_cut图生成逻辑：**
- 与after_cut相同，但使用`basic_cut`而不是`remove_cut`
- 显示未应用滤波窗口的原始数据

### 7. 统计信息输出

**统计指标计算：**

```cpp
int remove_num = 0;
int num_5k_total=0;
int num_5k_Incut=0;
int num_5k_Outcut=0;

// 统计总事件数和MDC>5000的事件数
for(int i=0;i<entries;i++){
    tr->GetEntry(i);
    if(nhit_TQ_total_mdc>5000) num_5k_total++;
}

// 统计过滤前后的事件数
for(int i=0;i<entries;i++){
    tr->GetEntry(i);
    if(!goodEvtFlag1 && TopupEvtFlag){
        remove_num++;
        if(nhit_TQ_total_mdc>5000) num_5k_Incut++;
    }
    if(goodEvtFlag1 && TopupEvtFlag){
        if(nhit_TQ_total_mdc>5000) num_5k_Outcut++;
    }
}

// 输出统计信息
cout<<setw(20)<<"remove ratio"<<setw(20)<<(double)remove_num/(double)entries<<endl;
cout<<setw(20)<<"remove_num"<<setw(20)<<remove_num<<setw(20)<<"TotalEvent"<<setw(20)<<entries<<endl;
cout<<setw(20)<<"num_5k_Incut/num_5k_total"<<setw(20)<<(double)num_5k_Incut/(double)num_5k_total<<endl;
```

---

## 六、步骤4.2：合并图片

### 功能描述

步骤4.2负责将所有run的检查图片合并为PDF文件，并下载到本地。

### 执行命令

**步骤4.2执行的命令：**

```bash
# 进入checkShieldCalib目录
cd /besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/checkShieldCalib

# 在SL6容器中合并图片
/cvmfs/container.ihep.ac.cn/bin/hep_container shell SL6
convert *.png mergedd_CheckShieldCalib.pdf
exit
```

### 参数说明

**步骤4.2支持以下参数：**

| 参数 | 类型 | 默认值 | 说明 |
|-----|------|--------|------|
| `date` | 字符串 | 可选 | 日期参数（如250519），如果未提供则从进度文件读取 |

### 输出文件

**远程文件：**
- 路径：`/besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/checkShieldCalib/mergedd_CheckShieldCalib.pdf`

**本地文件：**
- 路径：`C:\Users\孟皇薪\Desktop\topup\downloads\mergedd_CheckShieldCalib_{date}.pdf`

### 非topup模式说明

**在非topup模式下：**
- 不会生成PNG图片文件
- 步骤4.2执行时会失败（无法找到*.png文件）
- 这是正常现象，可以忽略
- 错误码4201、4202、4203的action已设置为continue

---

## 七、使用方法

### 基本用法

**执行步骤4.1（提交作业）：**

```bash
# 非topup模式（默认）
python run.py --step 4.1 --date 250519

# 或显式指定
python run.py --step 4.1 --date 250519 --check false
```

**执行步骤4.2（合并图片）：**

```bash
python run.py --step 4.2 --date 250519
```

### 完整流程

**使用all模式执行所有步骤：**

```bash
python run.py --all --date 250519 --check false
```

这将依次执行：
1. 步骤1.1-1.5
2. 步骤2.1-2.5
3. 步骤3.1-3.2
4. 步骤4.1-4.2
5. 步骤5.1-5.5
6. 步骤6.1-6.3

### 参数说明

**--check参数：**
- `true`：检查生成的文件（仅用于topup模式）
- `false`：不检查文件（默认，适用于非topup模式）

**--submit-job参数：**
- `true`：提交作业（默认）
- `false`：跳过作业提交

---

## 八、注意事项

### 1. 非topup模式

**非topup模式的特征：**
- IST值等于15000000
- 不会生成检查图片
- 步骤4.1中check参数应设为false
- 步骤4.2会失败，但可以忽略

### 2. 滤波窗口优化

**如果滤波效果不理想：**
1. 查看cut_detail图，识别未覆盖的峰值
2. 查看after_cut图，识别未过滤的背景（黑色竖线）
3. 修改window.dat文件
4. 重新执行步骤4.1和4.2
5. 重复直到满意

### 3. 文件清理

**步骤4.1会自动删除：**
- 旧PDF文件（`*.pdf`）
- 旧run开头的文件（`run*`）

这确保每次执行都是干净的状态。

### 4. 作业监控

**查看作业状态：**

```bash
ssh beslogin
cd /besfs5/groups/cal/topup/round18/DataValid/Determining_50Hz_cut/checkShieldCalib
qstat -u topup
```

### 5. 日志文件

**输出日志：**
- 作业日志：`run_{runNo}_4.txt.err.{pid}.0`
- 输出文件：`run{runNo}_output.txt`

---

## 九、错误处理

### 常见错误

**4201 - 执行图片合并失败：**
- 原因：目录中没有PNG文件
- 处理：非topup模式下的正常现象，可以忽略

**4202 - 图片合并成功，但文件下载失败：**
- 原因：SFTP连接问题或权限问题
- 处理：检查SSH连接，手动下载PDF文件

**4104 - 文件检查超时：**
- 原因：作业执行缓慢或部分作业失败
- 处理：增加`--max-wait`参数的值，或手动检查作业状态

### 错误代码参考

详见`error-dictionary/step4_errors.py`文件。

---

## 十、总结

### 步骤4的作用

步骤4是BESIII离线事件滤波器校准流程中的**验证与优化阶段**：

1. **输入**：
   - hist文件（包含MDC/EMC响应分布）
   - window.dat文件（包含滤波窗口参数）

2. **处理**：
   - 应用滤波窗口到hist数据
   - 生成4类检查图片
   - 统计过滤前后的数据变化
   - 合并图片为PDF

3. **输出**：
   - cut_detail图（滤波窗口详细）
   - after_cut图（滤波后）
   - before_cut图（滤波前）
   - check图（整体检查）
   - mergedd_CheckShieldCalib.pdf（合并PDF）
   - 统计信息（过滤比率等）

### 物理意义

通过应用滤波窗口并生成可视化检查图，步骤4实现了：
- **验证滤波器效果**：确认窗口能有效过滤注入背景
- **优化窗口参数**：通过可视化检查调整窗口边界
- **评估滤波器性能**：计算过滤比率，确保不过度过滤
- **支持迭代优化**：重复执行直到窗口参数最优

### 非topup模式支持

步骤4正确处理非topup模式（IST=15000000）：
- 自动检测非topup模式
- 跳过图片生成
- 避免无效计算
- 提供清晰的错误信息

---

**文档创建时间：** 2026年2月21日
**基于论文：** "Suppression of top-up injection backgrounds with offline event filter in the BESIII experiment" (Radiation Detection Technology and Methods, 2022)
**基于代码：** genJob.sh, checkCalibConst.cpp, step4_fourth_job_submission.py, step4_2_check_files.py
**基于操作手册：** 步骤16（合并图片并检查）