# Topup HTTP API 项目概览

## 🎯 项目目标

将现有的 Step1-8 数据处理任务转换为 HTTP API 形式，提供基于 Web 的任务管理和执行接口。

## ✨ 核心特性

- **RESTful API** - 完整的任务管理和控制接口
- **工作流管理** - 支持工作流版本管理和动态配置
- **实时状态追踪** - 任务执行状态和进度实时更新
- **步骤输出记录** - 详细记录每个步骤的输出和日志
- **任务控制** - 支持暂停、恢复、取消正在运行的任务
- **并发执行** - 支持多任务并发执行
- **错误处理** - 完善的错误处理和重试机制

## 📁 已完成的模块

### 1. 数据库层 (`models/`)
- ✅ `database.py` - 数据库连接和配置
- ✅ `task.py` - 完整的数据模型定义（8个表）

### 2. 核心引擎 (`core/`)
- ✅ `task_engine.py` - 任务执行引擎，管理整个任务生命周期
- ✅ `workflow_parser.py` - 工作流配置解析器
- ✅ `step_executor.py` - 单个步骤执行器
- ✅ `state_manager.py` - 状态管理器

### 3. API接口层 (`api/`)
- ✅ `app.py` - Flask应用主文件
- ✅ `routes/tasks.py` - 任务管理接口
- ✅ `routes/workflows.py` - 工作流管理接口
- ✅ `routes/executions.py` - 执行记录接口
- ✅ `routes/logs.py` - 日志查询接口
- ✅ `middleware/auth.py` - 认证中间件
- ✅ `middleware/error_handler.py` - 错误处理中间件

### 4. 业务服务层 (`services/`)
- ✅ `task_service.py` - 任务业务逻辑服务

### 5. 配置和工具
- ✅ `config.py` - 应用配置
- ✅ `requirements.txt` - Python依赖列表
- ✅ `.env.example` - 环境变量示例
- ✅ `database_schema.sql` - 完整的数据库Schema
- ✅ `workflows/topup_standard.json` - 标准工作流配置（21个步骤）

## 🚧 待实现的功能

### 优先级1 - 核心功能
1. **步骤具体实现** (`steps/`)
   - 将现有的step1_1到step8的代码适配到新的API框架
   - 需要修改执行命令以适配远程服务器长时间运行的情况

2. **数据库初始化**
   - 创建数据库初始化脚本
   - 加载默认工作流数据

3. **完善错误处理**
   - 增强SSH连接错误处理
   - 添加超时和重试逻辑

### 优先级2 - 增强功能
4. **WebSocket实时更新**
   - 实现任务进度实时推送
   - 支持多客户端订阅

5. **文件管理**
   - 输出文件下载接口
   - 文件哈希计算
   - 文件大小统计

6. **监控和日志**
   - 性能监控
   - 详细的执行日志
   - 错误统计

### 优先级3 - 可选功能
7. **Web界面**
   - 简单的管理界面
   - 任务可视化展示

8. **API文档**
   - Swagger/OpenAPI文档生成
   - 接口测试工具

## 🔧 技术架构

### 框架选择
- **Web框架**: Flask 3.0
- **ORM**: SQLAlchemy 2.0
- **数据库**: SQLite (开发), 可扩展到PostgreSQL
- **SSH**: Paramiko
- **实时通信**: Flask-SocketIO

### 设计模式
- **服务层模式**: 分离业务逻辑和API层
- **工厂模式**: 任务引擎和执行器创建
- **策略模式**: 工作流解析和执行
- **观察者模式**: 状态更新和事件通知

## 📊 数据流

```
用户请求 → API接口 → 任务服务 → 任务引擎
    → 工作流解析 → 步骤调度 → 步骤执行
    → SSH命令执行 → 结果收集 → 状态更新
    → 数据库存储 → 用户响应
```

## 🔄 任务执行流程

1. **创建任务**
   - 用户提交任务请求
   - 验证参数和工作流
   - 创建任务记录
   - 保存任务参数

2. **启动任务**
   - 检查任务状态
   - 建立SSH连接
   - 启动执行线程
   - 更新任务状态为running

3. **执行步骤**
   - 解析工作流配置
   - 按顺序执行步骤
   - 每个步骤：
     - 创建执行记录
     - 执行步骤函数
     - 检查输出文件
     - 更新执行状态
     - 记录日志

4. **完成/失败处理**
   - 更新任务状态
   - 清理资源
   - 发送通知

## 💡 关键设计决策

### 1. 使用SQLite而非PostgreSQL
**原因**:
- 部署简单，无需额外服务
- 满足当前项目规模需求
- 可以轻松迁移到PostgreSQL

### 2. 手写任务引擎而非使用Prefect
**原因**:
- 项目规模相对固定
- 保持轻量级架构
- 深度集成现有step模块
- 减少学习成本

### 3. 使用线程而非进程
**原因**:
- I/O密集型任务，线程足够
- 内存占用更小
- 实现更简单

### 4. 分离步骤实现和执行逻辑
**原因**:
- 便于单独测试每个步骤
- 支持步骤复用
- 易于维护和扩展

## 🎯 下一步行动计划

### 立即执行
1. **讨论步骤实现细节**
   - 哪些步骤需要修改执行命令？
   - 如何处理长时间运行的SSH命令？
   - 如何优雅地处理中断和恢复？

2. **实现第一个步骤**
   - 选择一个相对简单的步骤作为示例
   - 适配到新的框架
   - 测试执行

3. **完善框架**
   - 根据实际步骤执行情况调整
   - 修复发现的问题
   - 优化性能

### 后续计划
4. 批量实现所有步骤
5. 完善错误处理
6. 添加测试
7. 部署和监控

## 📝 需要讨论的问题

1. **步骤命令执行**
   - 现有步骤中使用 `execute_interactive_command`，长时间运行时如何处理？
   - 是否需要改进SSH命令执行方式？

2. **文件检查和输出**
   - 如何在远程服务器检查文件？
   - 是否需要下载文件到本地进行验证？

3. **错误恢复**
   - 任务失败后如何恢复？
   - 是否支持从失败步骤重新开始？

4. **并发控制**
   - 同时执行多少个任务合适？
   - 如何防止资源耗尽？

5. **日志和监控**
   - 需要多详细的日志？
   - 是否需要性能监控？

## 🤝 协作方式

我们将一起完成以下工作：

1. **框架调整** - 根据实际需求调整框架设计
2. **步骤实现** - 逐个实现步骤，讨论遇到的问题
3. **测试优化** - 测试并优化执行流程
4. **文档完善** - 完善使用文档和开发文档

准备好开始实现了吗？我们从一个简单的步骤开始吧！